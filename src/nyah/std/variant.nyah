@module std
@import std.pack

class variant[T...] {
    def operator=(v:const) {
        @assert (contains[v, T...])
        idx_  = index_of[v, T...]
        data_ = new[T](v)
    }

    def at[U] = {
        @assert (contains[U, T...])
        *reinterpret_cast[U *](data_)
    }

    def at[I:uint] = {
        @assert (I < sizeof... T)
        *reinterpret_cast[ T[I] *](data_)
    }

    def self(v:const) {
        @assert (contains[v, T...])
        idx_  = index_of[v, T...]
        data_ = new[T](v)
    }

    def self() {}
  @private:
    data_:void * = null
    idx_ = 0u
}

def variant_apply(v:variant[T...], functor:const) = {
    return_type ?: type_of[functor(T[0])]

    // @singleton within a function will create a new singleton for each
    // set of type parameters. lambda in singleton always copies the
    // functor.
    @singleton executors:ptr_array[sizeof...[T], executor_base] =
        [[
            i ? 0u .. sizeof...[T],
            lambda functor(T[i])
        ]]

    return executors(v.type_index)()
}
