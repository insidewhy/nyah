module std

import std.memory

class vector[T] {
    value_type    ?= T
    iterator_type ?= T*

    // +const generates both a mutable and a const version
  @+const:
    begin() = data_
    end()   = data_ + size - 1

    // & forces the return type to be a reference
    front():& = *begin()
    back():&  = *end()

    // clears +const property
  @mutable:
    resize(newSize:size_t) {
        if (newSize < capacity) {
            if (newSize < size) {
            }
        }
        else if (newSize > capacity) {
        }
    }

    self() {
        data_ = null
        size = 0
        capacity = 0
    }

    self(a?T const) {
        // if a function has only one type argument or argument then brackets
        // are not needed to call it e.g. new...
        data_ = new T
        size = 1
        capacity = 1
    }

    push_back(a?T const) {
        if (size == capacity - 1) {
            reallocate(data_, capacity *= 2)
        }
        copy(end(), a)
        ++size
    }

    size:uint
    capacity:size_t
  private:
    data_:T*
}
