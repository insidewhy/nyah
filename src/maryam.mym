# import all of regExp into this namespace
using regExp;

# import all basic types
using basic;

# import BinOp and PostFixOp templates from operator and make rest private
using expression BinOp, PostFixOp;

# any identifier
terminate := ';';

# any kind of rule that has been defined
abstract class Rule {
    id name;
}

# base class of anything that can be used as a rule in a rule expression
class DefinedRule {
    # a defined rule.. stores a reference to it's definition
    Rule definingRule := global(
        definingRule.name = id
    );

    begin := definingRule;
}

# this is what comes after a := in a rule expression.. it is all inlined into
# a list of expressions
inline class RuleExpression {
    expression :=
        DefinedRule | quotedString | characterRange | RegularExpressionMatch;

    # can pass undeclared type as a template parameter and it is filled in
    # when the rule gets defined tainting everything that uses it in the
    # mean-time
    BracketExpression(alternate) bracketExpression;

    expressionGroup := bracketExpression | expression;

    notExpression := PreFixOp('!', expressionGroup ) | expressionGroup

    repeater := PostFixOp('+', notExpression) | PostFixOp('*', notExpression) | notExpression;

    alernate := BinOp('|', repeater) | repeater;

    list( expressionGroup ) expressions := alternate+;

    begin := expressions;
}

# this class represents a simple (possibly inline) rule with no storage
class SimpleRule : Rule {
    # a compile time ordered set 
    set( private ) typeSpecifier;

    begin := typeSpecifier name ':=' RuleExpression;
}

class Attribute : SimpleRule, DefinedRule {
    set( unique ) attributeSpecifier;

    begin :=  attributeSpecifier super(0);
}

# an attribute that also has a rule describing restrictions on the attribute
class StorageRule : SimpleRule , Attribute {
    StorageType storeType := id : global(
        storeType.name = id
    );

    begin := storeType SimpleRule;
}

inline class ClassContents {
}

# inheriting from an inline class is like mixing the two class definitions into
# one
class Class : ClassContents {
    list( SimpleRule ) simpleRules;

    begin := 'class' id 
}


# the global begin.. everything allowed in a class is allowed in the global
# namespace and nothing else
begin := (ClassContents | Class) +
