# this also has other effects
inline class join(str, exp) {
    begin := exp (str exp)*
}

inline class escaped(quote, escape) {
    begin := quote ^ ( ( escape ^ . ) | . )+ ^ quote
}

# parse file with given extension using current language
function parse(extension = '') {
}

# an ordered list that can store any of the given types
inline class list(types...) {

    # overloads
    operator parent {
        # commute to every element of the list
    }

    operator & {
        # call begin& on every element of current list ensuring all
        # mandatory conditions are valid parsing as we go
    }
}

# hey poopy poop face I miss you. *Honor Me For Eva* 

# join is specialised over list
inline class join(str, exp >= collection) {
    # call begin over and over until there are no more joins pushing back each
    # match to the list
}

# join is specialised over reference to list list
inline class join(str, exp >= collection&) {
    # match begin& for each element in the referred to list with as many joined
    # elements as we have, then continue to match begin& with
    # special type null for remaining parameters in the NON reference case
}

# if this is the type of a rule then store true if it is matched, else false
type bool;

# flatten the elements out into a string
type string;

# convert string arguments to corresponding numbers
type int;
type long;
type float;
type double;
