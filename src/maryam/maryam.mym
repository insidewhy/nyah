# import all of regExp into this namespace
using regExp;

# import all basic types
using basic;

# for filenames
using os;

# import BinOp and PostFixOp templates from operator and make rest private
using expression BinOp, PostFixOp;

# any identifier
terminate := ';';

# any kind of rule that has been defined
abstract class RuleOrClass {
    # key also implies mandatory and is shared by a rule and a class so you
    # can't have rules and classes with the same name now :)
    key id name;
}

################################################################################
# class template parameters
################################################################################
# class definition baby
# like for defined rule but matches classes, keys are for searching
class ClassAbstract : RuleOrClass {
    begin := 'class' name;
}

class TemplateClassAbstract : ClassAbstract {
    class Parameter {
        # search : global(class.name = id) implied by reference and key
        ClassAbstract& default;
        key id name;
        begin := name ('=' default)?;

        # the type below is only used by a reference constructor, the compiler
        # knows not to instatiate it for non-needed types and also that it
        # must store data with the reference type.
        mandatory ClassAbstract& parameterClass := ClassAbstract& | {  
            if (default, parameterClass = default, error('invalid template parameter'));
        };

        # when constructing a reference to ClassAbstract use this constructor
        TemplateClassAbstract.begin& := parameterClass;
        # otherwise use a default which would just be the key on name
    }

    # the join will instatiate the class parameters in the correct order for
    # the reference case and ensure all mandatory elements for the reference
    # versions are set
    ordered_set< Parameter > classParameters := '(' join<',', Parameter> ')';

    # super always called first
    begin := classParameters;

}

class RuleAbstract : RuleOrClass {
    begin := name;
    # reference constructor used to build reference to this type, if there is
    # no reference constructor just use the normal constructor
}

# this is what comes after a := in a rule expression.. it is all inlined into
# a list of expressions
class RuleExpression {
    # the RuleAbstract&, ClassAbstract& etc. can be non-abstract versions as
    # long as the reference begin still matches and is not overridden
    anyDigit     := '\d';
    nonDigit     := '\D';
    anyChar      := '.';
    anyWordChar  := '\w';
    nonWordChar  := '\W';
    newLine      := '\n';
    nonNewLine   := '\N';
    tab          := '\t';

    expression := ( RuleAbstract& | ClassAbstract& | TemplateClassAbstract& |
                    quotedString | CharacterRange | RegularExpressionMatch |
                    anyDigit | nonDigit | anyChar | anyWordChar | nonWordChar | 
                    newLine | nonNewLine | tab );


    bracketExpression := BracketExpression<this> | BracketExpression<this, '[', ']'>;

    expressionGroup := bracketExpression | expression;

    notExpression := PreFixOp('!', expressionGroup ) | expressionGroup;

    repeater := PostFixOp('+', notExpression) | 
                PostFixOp('*', notExpression) | 
                PostFixOp('?', notExpression) | 
                notExpression;

    joiner := join<'^', repeater>;

    alternate := join<'|', joiner>;

    # each alternate has a sublist of joiner, each joiner having a sublist
    # of type repeater. the results are propogated through the rules
    list< alternate, joiner, repeater, notExpression,
          expressionGroup, bracketExpression, expression > expressions;

    contents := expressions;
}

# this class represents a simple (possibly private) rule with no storage
class Rule : RuleAbstract {
    # a compile time bitset which has an enum with the same names as the
    # strings it matches, multi because you can specify many options
    multi_bit_set( private, key, parent ) typeSpecifier;

    RuleExpression expression;

    begin := typeSpecifier name ':=' expression;
    end := terminate;
}

class Attribute : RuleAbstract {
    bit_set( unique, mandatory ) attributeSpecifier;

    # TODO: I don't think we need to delay stuff anymore or use searches
    # delay lookup modifier makes type expression not look up it's classes
    # until the end of the file (in case the match is a reference type to a
    # class that hasn't been defined yet)
    RuleExpression typeExpression [ delayLookup() ];
    RuleExpression expression;

    class SearchExpression {
        # TODO: Finish this
        AbstractClass searchScope;
        bool isGlobal := 'global';
        begin := ':' (searchScope | isGlobal) '(';

        class SearchItem {
            # this will respect the delayed lookup on the type expression
            # so will not error if the type expression hasn't been set yet
            
        }
        list<SearchItem> searches;

        contents := searches;

        end := ')';
    }
    SearchExpression search;

    # we can only have a reference type if there is a search, if there isn't 
    # do the lookup
    begin { if( ! search, lookup(typeExpression)) } 
        := attributeSpecifier typeExpression name ( ':=' expression )? search? ;
}

################################################################################
# the class
################################################################################
class Class : ClassAbstract {
    list< Rule >    rules;
    list< Class >   nestedClasses;

    # the parent modifier sets all the types within the reference class as
    # parents of this
    parent list< AbstractClass& , TemplateAbstractClass& > classParents := 
                                                    ':' join<',', classParents>;

    # this goes after the parent class shit
    begin := super classParents? '{';

    contents :=  rules | nestedClasses;

    end := '}';
} 

class TemplateClass : TemplateClassAbstract {
    list< Rule >    rules;
    list< Class >   nestedClasses;

    class Parents {
        Parameter&      parameter;
        parent (AbstractClass& | TemplateAbstractClass&)  class_;

        begin := parameter | class_;

        TemplateClass.begin& := class_ | parameter { 
            class_ = parameter.parameterClass 
        };
    }

    parent list< Parents > classParents := ':' join<',', classParents>;

    contents :=  rules | nestedClasses;

    end := '}';
}

# make global inherit from class since anything that can be in a class can
# also be in the global namespace
class Global : Class {
    class UsingStatement {
        # parse() passed implicitly fileName type and can handle it
        fileName useFilename { parse< extension = 'mym'> };

        # TODO: take elements out of tree that do not match specifier
        list< id > importedElements := id (',' id)*;

        begin := 'using' useFilename importedElements?;

        end := terminate;
    }

    list< UsingStatement > usingStatements;

    # the contents rule can be matched anywhere after the constructor rule
    # and may be matched multiple times
    # NOTE: contents of children classes have higher priorities than the
    # parent classes so GlobalClass will get matched ahead of Class
    contents := UsingStatement | nestedClasses | rules;
}

# the global begin.. everything allowed in a class is allowed in the global
# namespace along with using statements (class is allowed in class contents)
