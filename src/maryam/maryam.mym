# import all of regExp into this namespace
using regExp;

# import all basic types
using basic;

# for filenames
using os;

# import BinOp and PostFixOp templates from operator and make rest private
using expression BinOp, PostFixOp;

# any identifier
terminate := ';';

# any kind of rule that has been defined
abstract class RuleOrClass {
    # key also implies mandatory and is shared by a rule and a class so you
    # can't have rules and classes with the same name now :)
    key id name;
}

################################################################################
# class template parameters
################################################################################
# class definition baby
# like for defined rule but matches classes, keys are for searching
class ClassAbstract : RuleOrClass {
    # inline mixes the scope of this class into the current class
    inline class Parameter {
        # search : global(class.name = id) implied by reference and key
        ClassAbstract& default;
        begin := name ('=' default)?;

        # the type below is only used by the reference constructor, the compiler
        # knows not to instatiate it for non reference types.
        # the alias makes class lookups within the class body work, the alias
        # will only affect the scope if it's through inheritence
        mandatory (ClassAbstract& | default) parameterClass { alias(name, parameterClass.name) };
        begin& := parameterClass;
    }

    # the join will instatiate the class parameters in the correct order for
    # the reference case and ensure all mandatory elements for the reference
    # versions are set
    ordered_set( Parameter ) classParameters := 
        '(' join(',', Parameter) ')';

    begin := 'class' name classParameters?;

    begin& := name classParameters?;
}

class RuleAbstract : RuleOrClass {
    begin := name
    # reference constructor used to build reference to this type, if there is
    # no reference constructor just use the normal constructor
}

# this is what comes after a := in a rule expression.. it is all inlined into
# a list of expressions
class RuleExpression {
    ( RuleAbstract& | ClassAbstract& | quotedString | 
    CharacterRange | RegularExpressionMatch ) expression;

    bracketExpression := BracketExpression(this) | BracketExpression(this, '<', '>');

    expressionGroup := bracketExpression | expression;

    notExpression := PreFixOp('!', expressionGroup ) | expressionGroup

    repeater := PostFixOp('+', notExpression) | 
                PostFixOp('*', notExpression) | 
                PostFixOp('?', notExpression) | 
                notExpression

    joiner := join('^', repeater);

    alternate := join('|', joiner);

    # each alternate has a sublist of joiner, each joiner having a sublist
    # of type repeater. the results are propogated through the rules
    list( alternate, joiner, repeater ) expressions := alternate+;

    begin := expressions;
}

# this class represents a simple (possibly private) rule with no storage
class Rule : RuleAbstract {
    # a compile time bitset which has an enum with the same names as the
    # strings it matches, multi because you can specify many options
    multi_bit_set( private, key, parent ) typeSpecifier;

    RuleExpression expression;

    begin := typeSpecifier name ':=' expression;
    end := terminate;
}

class Attribute : RuleAbstract {
    bit_set( unique, mandatory ) attributeSpecifier;

    # delay lookup modifier makes type expression not look up it's classes
    # until the end of the file (in case the match is a reference type to a
    # class that hasn't been defined yet)
    RuleExpression typeExpression [ delayLookup() ];
    RuleExpression expression;

    class SearchExpression {
        # TODO: Finish this
        AbstractClass searchScope;
        bool isGlobal := 'global';
        begin := ':' (searchScope | isGlobal) '(';

        class SearchItem {
            # this will respect the delayed lookup on the type expression
            # so will not error if the type expression hasn't been set yet
            
        }
        list(SearchItem) searches;

        contents := searches;

        end := ')';
    }
    SearchExpression search;

    # we can only have a reference type if there is a search, if there isn't 
    # do the lookup
    begin { if( ! search, lookup(typeExpression)) } 
        := attributeSpecifier typeExpression name ( ':=' expression )? search? ;
}

class BeginRule : Rule {
    name := 'begin';
}

class ContentsRule : Rule {
    name := 'contents';
}

class EndRule : Rule {
    name := 'end';
}

################################################################################
# the class
################################################################################
class Class : ClassAbstract {
    # attributes
    list( Rule )    rules;
    list( Class )   subClasses;

    # unique, they can be matched more than once but the second will error
    unique BeginRule beginRule;
    unique EndRule endRule;
    unique ContentsRule contentsRule;

    # the parent modifier sets all the types within the reference class as
    # parents of this
    parent ordered_set( AbstractClass& ) classParents := ':' join(',', AbstractClass&);

    # this goes after the parent class shit
    begin := super classParents? '{';

    contents :=  beginRule | endRule | contentsRule | rules | subClasses;

    end := '}';
} 

# make global inherit from class since anything that can be in a class can
# also be in the global namespace
class Global : Class {
    class UsingStatement {
        # importFile() passed implicitly fileName type and can handle it
        os.fileName useFilename { parse( extension := 'mym') };

        # TODO: take elements out of tree that do not match specifier
        list( id ) importedElements := id (',' id)*;

        begin := 'using' useFilename importedElements?;

        end := terminate;
    }

    list( UsingStatement ) usingStatements;

    # the contents rule can be matched anywhere after the constructor rule
    # and may be matched multiple times
    # NOTE: contents of children classes have higher priorities than the
    # parent classes so GlobalClass will get matched ahead of Class
    contents := UsingStatement | globalClass | classes | rules;
}

# the global begin.. everything allowed in a class is allowed in the global
# namespace along with using statements (class is allowed in class contents)
