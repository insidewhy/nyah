# import all of regExp into this namespace
using regExp;

# import all basic types
using basic;

# for filenames
using os;

# import BinOp and PostFixOp templates from operator and make rest private
using expression BinOp, PostFixOp;

# any identifier
terminate := ';';

# any kind of rule that has been defined
abstract class RuleAbstract {
    mandatory id name;
}

# convenience storage expression for looking up a rule from an id and storing 
# a reference to it in RuleAbstract
class DefinedRule {
    RuleAbstract rule := id : global( rule.name = id );
    
    begin := rule;
}

# this is what comes after a := in a rule expression.. it is all inlined into
# a list of expressions
class RuleExpression {
    expression :=
        DefinedRule | quotedString | CharacterRange | RegularExpressionMatch;

    bracketExpression := BracketExpression(this);

    expressionGroup := bracketExpression | expression;

    notExpression := PreFixOp('!', expressionGroup ) | expressionGroup

    repeater := PostFixOp('+', notExpression) | 
                PostFixOp('*', notExpression) | 
                PostFixOp('?', notExpression) | 
                notExpression |
                BracketExpression(this, '<', '>');

    joiner := repeater ('^' repeater)* | BracketExpression(this, '<', '>');

    alternate := joiner ('|' joiner)*;

    # each alternate has a sublist of joiner, each joiner having a sublist
    # of type repeater. the results are propogated through the rules
    list( alternate, joiner, repeater ) expressions := alternate+;

    begin := expressions;
}

# this class represents a simple (possibly private) rule with no storage
class Rule : RuleAbstract {
    # a compile time bitset which has an enum with the same names as the
    # strings it matches
    bit_set( private ) typeSpecifier;

    RuleExpression expression;

    begin := typeSpecifier name ':=' expression;
    end := terminate;
}

class SearchExpression {
    # TODO: Finish this
    begin := ':';
}

class Attribute : RuleAbstract {
    bit_set( unique, mandatory, search ) attributeSpecifier;

    RuleExpression typeExpression;
    RuleExpression expression;
    SearchExpression search;

    begin := attributeSpecifier typeExpression name 
             ( ':=' expression )? search? ;
}

class BeginRule : Rule {
    name := 'begin';
}

class EndRule : Rule {
    name := 'end';
}

class ClassAbstract {
    id name;
}

class DefinedClass {
    ClassAbstract class := id : global( class.name = id );
    begin := class;
}

################################################################################
# class template parameters
################################################################################
abstract class Parameter {
    id name;
}
class CharParameter : Parameter {
    character default;
    begin := 'char' name ('=' default)?;
}
class StringParameter : DefinedRule {
    DefinedRule | quotedString default;
    begin := 'string' name ('=' default)?;
}
class IntParameter : Parameter {
    integer default;
    begin := 'int' name ('=' default)?;
}
class ClassParameter : Parameter {
    DefinedClass default;
    begin := 'class'? name ('=' default)?;
}

parameter := ClassParameter | IntParameter | StringParameter | CharParameter;

################################################################################
# the class
################################################################################
class ParentClass {
    # when matching search down into the class this parent class references
    search ClassAbstract class := id : global( class.name = id );
    ClassParameter classParameter := id : global( classParameter.name = id );

    begin := class | classParameter;
}

class Class : ClassAbstract {
    # attributes
    list( Rule ) rules;

    # unique, they can be matched more than once but the second will error
    unique BeginRule beginRule;
    unique EndRule endRule;

    ordered_set( parameter ) classParameters := 
        '(' parameter ( ',' parameter ) * ')';

    ordered_set( ParentClass ) classParent := ':' ParentClass (',' ParentClass)* ;

    begin := 'class' classParameters? name '{' (rules | beginRule | endRule)*;

    end := '}';
} 

class UsingStatement {
    # importFile() passed implicitly fileName type and can handle it
    fileName useFilename { importFile() };

    # TODO: take elements out of tree that do not match specifier
    list( id ) importedElements := id (',' id)*;

    begin := 'using' useFilename (importedElements);

    end := terminate;
}

# the global begin.. everything allowed in a class is allowed in the global
# namespace along with using statements (class is allowed in class contents)
begin := (ClassContents | UsingStatement) + 
