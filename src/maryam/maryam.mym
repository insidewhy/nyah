# import all of regExp into this namespace
using regExp;

# import all basic types
using basic;

# for filenames
using os;

# any identifier
# rule := <blah> equivalent to
# class rule {
#   begin:= <blah>;
# }
terminate := ';';

# any kind of rule that has been defined
# abstract classes can not be instantiated but a reference to an abstract class
# can be used to say that the reference can point to any deriving class
abstract class RuleAbstract {
    id name;

    begin := name;
}

################################################################################
# class template parameters
################################################################################
# class definition baby
# like for defined rule but matches classes, keys are for searching
abstract class ClassAbstract : RuleAbstract {
    begin  := 'class' super;
 
    # use super begin (name) as reference, the superclass has no reference
    # constructor so use the superclass' normal constructor
    begin& := super;
}

class Reference {
    # this could also point to a TemplateClass etc.
    ClassAbstract& class_;
    begin := class_ '&';
}

class TemplateClassAbstract : ClassAbstract {
    class Parameter {
        RuleAbstract& default;
        RuleAbstract& restriction;

        # we can tell that the parameter name must be unique from the reference constructor
        id name;

        # default constructor
        begin := name ('=' default)? (':' restriction)?;

        # the type below is only used by a TemplateClassAbstract reference constructor, the compiler
        # knows not to instatiate it for non-needed types and also that it must store data with the 
        # reference type.
        RuleAbstract& parameter := 
            RuleAbstract& {
                if(restriction and (not parameter is ClassAbstract or not parent_child(restriction, parameter)),
                   error('parent/child restriction not satisfied'))
            }
            | null { 
                if (default, parameter = default, error('missing template parameter'));
            };

        # when constructing a reference to TemplateClassAbstract use this constructor
        TemplateClassAbstract:begin& := parameter;
        begin& := name;
    }

    # in the reference case the join will call begin& on every parameter with the
    # value for the parameter if the list has it otherwise null
    list< Parameter > parameters;

    # super always called first
    classParameters := '(' join<',', parameters> ')';
    begin           := classParameters?;

    templateArgs := '<' join<',', parameters> '>';

    begin&       := templateArgs?;
}

# TODO: document node collapsing rules and how we know we need to store a tree
#       when a class references itself.
class Test {

    test := (Test | RuleAbstract& | ClassAbstract& 'is' ClassAbstract&);
    notRule := ('!' | 'not')? [ test ];
    andRule := join<'and' | '&&', notRule>;
    orRule := join<'or' | '||', andRule>; 
    bracketRule := ('(' orRule ')') | orRule;

    (bracketRule | orRule | andRule | notRule | RuleAbstract& | test) expression;

    begin := expression;
}

class Action {
    class If {
        Test test;

        Action ifClause;
        Action elseClause;
        begin := 'if' '(' test ',' ifClause (',' elseClause)? ')';
    }

    class Assignment {
        # TODO: more actions
        RuleAbstract& destRule;
        RuleAbstract& srcRule;
        begin := destRule '=' srcRule;
    }

    class Error {
        begin := 'error' '(' quotedString ')';
    }

    # a list of one if/error/assignment will be collapsed in the tree
    list<If, Error, Assignment> actions;

    begin := join<';', actions>;
    end   := ;
}

# this is what comes after a := in a rule expression.. it is all inlined into
# a list of expressions
class RuleExpression {
    # the RuleAbstract&, ClassAbstract& etc. can be non-abstract versions as
    # long as the reference begin still matches and is not overridden
    anyDigit     := '\d';
    nonDigit     := '\D';
    anyChar      := '.';
    anyWordChar  := '\w';
    nonWordChar  := '\W';
    newLine      := '\n';
    nonNewLine   := '\N';
    tab          := '\t';
    _null        := 'null';

    action := '{' Action '}';

    expr := ( RuleAbstract& | # the former implies these: ClassAbstract& | TemplateClassAbstract& |
              quotedString | CharacterRange | RegularExpressionMatch |
              anyDigit | nonDigit | anyChar | anyWordChar | nonWordChar | 
              newLine | nonNewLine | tab | _null | this ) action?;


    bracketExpression := ( BracketExpression<this> | BracketExpression<this, '[', ']'> ) action?;

    expressionGroup := bracketExpression | expr;

    notExpression := '!'? expressionGroup action?;

    repeater := notExpression '+' | 
                notExpression '*' | 
                notExpression '?' | 
                notExpression;

    joiner := join<'^', repeater>;

    alternate := join<'|', joiner>;

    # each alternate has a sublist of joiner, each joiner having a sublist
    # of type repeater. the results are propogated through the rules
    (alternate | jointer | repeater | notExpression | expressionGroup |
     bracketExpression | expr ) expression;

    begin := expression;
}

# this class represents a simple (possibly private) rule with no storage
class Rule : RuleAbstract {
    # a compile time bitset which has an enum with the same names as the
    # strings it matches, multi because you can specify many options
    multi_bit_set( private, parent ) typeSpecifier;

    RuleExpression expression;

    bool isReference := '&';

    begin := typeSpecifier name isReference ':=' expression;
    end := terminate;
}

class Attribute : RuleAbstract {
    # bit_set( ... ) attributeSpecifier;
    # bool isUnique 

    RuleExpression typeExpression;
    RuleExpression expression;

    begin := typeExpression super ( ':=' expression )?;
}

################################################################################
# the class
################################################################################
class Class : ClassAbstract {
    list< Rule >    rules;
    list< Class >   nestedClasses;

    # the parent modifier sets the scope within all the classes as a parent
    # of the current scope
    parent list< AbstractClass& , TemplateAbstractClass& > classParents := 
                                                    ':' join<',', classParents>;

    # this goes after the parent class shit
    begin := classParents? '{';

    contents :=  rules | nestedClasses;

    end := '}';
} 

class TemplateClass : TemplateClassAbstract {
    list< Rule >    rules;
    list< Class >   nestedClasses;

    class Parents {
        Parameter&      parameter;
        parent (AbstractClass& | TemplateAbstractClass&)  class_;

        begin := parameter | class_;

        # if a begin& constructor modifies a class then a copy is created
        # on the tree after the location of the previous copy
        begin& := class_ | parameter { 
            class_ = parameter.parameterClass 
        };
    }

    parent list< Parents > classParents := ':' join<',', classParents>;

    contents :=  rules | nestedClasses;

    end := '}';
}

# make global inherit from class since anything that can be in a class can
# also be in the global namespace
class Global : Class {
    class UsingStatement {
        # parse() passed implicitly fileName type and can handle it
        fileName useFilename { parse< extension = 'mym'> };

        # TODO: take elements out of tree that do not match specifier
        list< id > importedElements := id (',' id)*;

        begin := 'using' useFilename importedElements?;

        end := terminate;
    }

    list< UsingStatement > usingStatements;

    # the contents rule can be matched anywhere after the constructor rule
    # and may be matched multiple times
    # NOTE: contents of children classes have higher priorities than the
    # parent classes so GlobalClass will get matched ahead of Class
    contents := UsingStatement | nestedClasses | rules;
}

# the global begin.. everything allowed in a class is allowed in the global
# namespace along with using statements (class is allowed in class contents)
