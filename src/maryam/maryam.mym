# import all of regExp into this namespace
using regExp;

# import all basic types
using basic;

# for filenames
using os;

# import BinOp and PostFixOp templates from operator and make rest private
using expression BinOp, PostFixOp;

# any identifier
terminate := ';';

# any kind of rule that has been defined
abstract class RuleAbstract {
    mandatory id name;
}

# convenience storage expression for looking up a rule from an id and storing 
# a reference to it in RuleAbstract
class DefinedRule {
    RuleAbstract rule := id : global( rule.name = id );
    
    begin := rule;
}

################################################################################
# class template parameters
################################################################################
# class definition baby
class DefinedClass {
    ClassAbstract class := id : global( class.name = id );
    begin := class;
}

class Parameter {
    DefinedClass default;
    begin := name ('=' default)?;
}

# like for defined rule but matches classes
class ClassAbstract {
    id name;
    ordered_set( Parameter ) classParameters := 
        '(' Parameter ( ',' Parameter ) * ')';
}

# this is what comes after a := in a rule expression.. it is all inlined into
# a list of expressions
class RuleExpression {
    expression :=
        DefinedRule | DefinedClass | quotedString | 
        CharacterRange | RegularExpressionMatch;

    bracketExpression := BracketExpression(this);

    expressionGroup := bracketExpression | expression;

    notExpression := PreFixOp('!', expressionGroup ) | expressionGroup

    repeater := PostFixOp('+', notExpression) | 
                PostFixOp('*', notExpression) | 
                PostFixOp('?', notExpression) | 
                notExpression |
                BracketExpression(this, '<', '>');

    joiner := repeater ('^' repeater)* | BracketExpression(this, '<', '>');

    alternate := joiner ('|' joiner)*;

    # each alternate has a sublist of joiner, each joiner having a sublist
    # of type repeater. the results are propogated through the rules
    list( alternate, joiner, repeater ) expressions := alternate+;

    begin := expressions;
}

# this class represents a simple (possibly private) rule with no storage
class Rule : RuleAbstract {
    # a compile time bitset which has an enum with the same names as the
    # strings it matches
    bit_set( private ) typeSpecifier;

    RuleExpression expression;

    begin := typeSpecifier name ':=' expression;
    end := terminate;
}

class Attribute : RuleAbstract {
    bit_set( unique, mandatory, search ) attributeSpecifier;

    # delay lookup modifier makes type expression not look up it's classes
    # until the end of the file (in case the match is a reference type to a
    # class that hasn't been defined yet)
    RuleExpression typeExpression [ delayLookup() ];
    RuleExpression expression;

    class SearchExpression {
        # TODO: Finish this
        DefinedClass searchScope;
        bool isGlobal := 'global';
        begin := ':' (searchScope | isGlobal) '(';

        class SearchItem {
        }
        list(SearchItem) searches;

        contents := searches;

        end := ')';
    }
    SearchExpression search;

    # we can only have a reference type if there is a search, if there isn't 
    # do the lookup
    begin { if( ! search, lookup(typeExpression)) } 
        := attributeSpecifier typeExpression name ( ':=' expression )? search? ;
}

class BeginRule : Rule {
    name := 'begin';
}

class ContentsRule : Rule {
    name := 'contents';
}

class EndRule : Rule {
    name := 'end';
}

################################################################################
# the class
################################################################################
class ParentClass {
    # when matching search down into the class this parent class references
    search ClassAbstract class := id : global( class.name = id );
    Parameter classParameter := id : global( classParameter.name = id );

    begin := class | classParameter;
}

class Class : ClassAbstract {
    # attributes
    list( Rule ) rules;

    # unique, they can be matched more than once but the second will error
    unique BeginRule beginRule;
    unique EndRule endRule;
    unique ContentsRule contentsRule;

    ordered_set( ParentClass ) classParents := ':' ParentClass (',' ParentClass)* ;

    begin := 'class' classParameters? name classParents '{';

    contents :=  beginRule | endRule | contentsRule | rules;

    end := '}';
} 

class GlobalClass : Class {
    begin := 'class' 'global' name classParents '{';
}

# make global inherit from class since anything that can be in a class can
# also be in the global namespace
class global : Class {
    class UsingStatement {
        # importFile() passed implicitly fileName type and can handle it
        fileName useFilename { parse( extension := 'mym') };

        # TODO: take elements out of tree that do not match specifier
        list( id ) importedElements := id (',' id)*;

        begin := 'using' useFilename (importedElements);

        end := terminate;
    }

    list( UsingStatement ) usingStatements;
    unique GlobalClass globalClass;
    
    # the contents rule can be matched anywhere after the constructor rule
    # and may be matched multiple times
    # NOTE: contents of children classes have higher priorities than the
    # parent classes so GlobalClass will get matched ahead of Class
    contents := UsingStatement | globalClass;
}

# the global begin.. everything allowed in a class is allowed in the global
# namespace along with using statements (class is allowed in class contents)
