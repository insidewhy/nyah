# import all of regExp into this namespace
using regExp;

# import all basic types
using basic;

# for filenames
using os;

# import BinOp and PostFixOp templates from operator and make rest private
using expression BinOp, PostFixOp;

# any identifier
terminate := ';';

# any kind of rule that has been defined
# abstract classes can not be instantiated but a reference to an abstract class
# can be used to say that the reference can point to any deriving class
abstract class RuleAbstract {
    # key also implies mandatory and is shared by a rule and a class so you
    # can't have rules and classes with the same name now :)
    id name;

    begin := name;
}

################################################################################
# class template parameters
################################################################################
# class definition baby
# like for defined rule but matches classes, keys are for searching
abstract class ClassAbstract : RuleAbstract {
    begin  := 'class' super;
 
    # use super begin (name) as reference, the superclass has no reference
    # constructor so use the superclass' normal constructor
    begin& := super;
}

class TemplateClassAbstract : ClassAbstract {
    class Parameter {
        # search : global(class.name = id) implied by reference and key
        ClassAbstract& default;

        # all parameters in the list must have a unique name
        unique id name;

        # default constructor
        begin := name ('=' default)?;

        # the type below is only used by a reference constructor, the compiler
        # knows not to instatiate it for non-needed types and also that it
        # must store data with the reference type.
        mandatory ClassAbstract& parameterClass := ClassAbstract& | null { 
            if (default, parameterClass = default, error('missing template parameter'));
        };

        # when constructing a reference to TemplateClassAbstract use this constructor
        # TemplateClassAbstract.begin& := parameterClass;
        begin& := parameterClass;
    }

    # the join will instatiate the class parameters in the correct order for
    # the reference case and ensure all mandatory elements for the reference
    # versions are set
    list< Parameter > parameters;

    # super always called first
    classParameters := '(' join<',', parameters> ')';
    begin           := classParameters?;

    templateArgs := '<' join<',', parameters> '>';
    begin&       := templateArgs?;

}

class Test {
    # TODO: more types of test
    bool invert := '!';
    RuleAbstract& testRule;

    begin := invert? testRule;
}

class Action {
    class If {
        Test test;

        Action ifClause;
        Action elseClause;
        begin := 'if' '(' test ',' ifClause (',' elseClause)? ')';
    }

    class Assignment {
        # TODO:
        RuleAbstract& destRule;
        RuleExpression srcExpression;
        RuleAbstract& srcRule;
        begin := destRule '=' (srcExpression | srcRule);
    }

    class Error {
        begin := 'error' '(' quotedString ')';
    }

    list<If, Error, Assignment> actions;

    begin := '{' join<';', actions>;
    end   := '}';
}

# this is what comes after a := in a rule expression.. it is all inlined into
# a list of expressions
class RuleExpression {
    # the RuleAbstract&, ClassAbstract& etc. can be non-abstract versions as
    # long as the reference begin still matches and is not overridden
    anyDigit     := '\d';
    nonDigit     := '\D';
    anyChar      := '.';
    anyWordChar  := '\w';
    nonWordChar  := '\W';
    newLine      := '\n';
    nonNewLine   := '\N';
    tab          := '\t';
    _null        := 'null';

    expression := ( RuleAbstract& | ClassAbstract& | TemplateClassAbstract& |
                    quotedString | CharacterRange | RegularExpressionMatch |
                    anyDigit | nonDigit | anyChar | anyWordChar | nonWordChar | 
                    newLine | nonNewLine | tab | _null ) Action?;


    bracketExpression := ( BracketExpression<this> | BracketExpression<this, '[', ']'> ) Action?;

    expressionGroup := bracketExpression | expression;

    notExpression := ( PreFixOp('!', expressionGroup ) Action? ) | ( expressionGroup Action? );

    repeater := PostFixOp('+', notExpression) | 
                PostFixOp('*', notExpression) | 
                PostFixOp('?', notExpression) | 
                notExpression;

    joiner := join<'^', repeater>;

    alternate := join<'|', joiner>;

    # each alternate has a sublist of joiner, each joiner having a sublist
    # of type repeater. the results are propogated through the rules
    list< alternate, joiner, repeater, notExpression > expressions;

    contents := expressions;
}

# this class represents a simple (possibly private) rule with no storage
class Rule : RuleAbstract {
    # a compile time bitset which has an enum with the same names as the
    # strings it matches, multi because you can specify many options
    multi_bit_set( private, key, parent ) typeSpecifier;

    RuleExpression expression;

    begin := typeSpecifier name ':=' expression;
    end := terminate;
}

class Attribute : RuleAbstract {
    bit_set( unique, mandatory ) attributeSpecifier;

    RuleExpression typeExpression;
    RuleExpression expression;

    begin := attributeSpecifier typeExpression super ( ':=' expression )?;
}

################################################################################
# the class
################################################################################
class Class : ClassAbstract {
    list< Rule >    rules;
    list< Class >   nestedClasses;

    # the parent modifier sets the scope within all the classes as a parent
    # of the current scope
    parent list< AbstractClass& , TemplateAbstractClass& > classParents := 
                                                    ':' join<',', classParents>;

    # this goes after the parent class shit
    begin := classParents? '{';

    contents :=  rules | nestedClasses;

    end := '}';
} 

class TemplateClass : TemplateClassAbstract {
    list< Rule >    rules;
    list< Class >   nestedClasses;

    class Parents {
        Parameter&      parameter;
        parent (AbstractClass& | TemplateAbstractClass&)  class_;

        begin := parameter | class_;

        # TemplateClass.begin& := class_ | parameter { 
        begin& := class_ | parameter { 
            class_ = parameter.parameterClass 
        };
    }

    parent list< Parents > classParents := ':' join<',', classParents>;

    contents :=  rules | nestedClasses;

    end := '}';
}

# make global inherit from class since anything that can be in a class can
# also be in the global namespace
class Global : Class {
    class UsingStatement {
        # parse() passed implicitly fileName type and can handle it
        fileName useFilename { parse< extension = 'mym'> };

        # TODO: take elements out of tree that do not match specifier
        list< id > importedElements := id (',' id)*;

        begin := 'using' useFilename importedElements?;

        end := terminate;
    }

    list< UsingStatement > usingStatements;

    # the contents rule can be matched anywhere after the constructor rule
    # and may be matched multiple times
    # NOTE: contents of children classes have higher priorities than the
    # parent classes so GlobalClass will get matched ahead of Class
    contents := UsingStatement | nestedClasses | rules;
}

# the global begin.. everything allowed in a class is allowed in the global
# namespace along with using statements (class is allowed in class contents)
