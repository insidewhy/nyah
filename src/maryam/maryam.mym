# import all of regExp into this namespace
using regExp;

# import all basic types
using basic;

# for filenames
using os;

# import BinOp and PostFixOp templates from operator and make rest private
using expression BinOp, PostFixOp;

# any identifier
terminate := ';';

# any kind of rule that has been defined
abstract class RuleAbstract {
    mandatory id name;
}

# convenience storage expression for looking up a rule from an id and storing 
# a reference to it in RuleAbstract
class DefinedRule {
    RuleAbstract rule := id : global( rule.name = id );
    
    begin := rule;
}

# this is what comes after a := in a rule expression.. it is all inlined into
# a list of expressions
class RuleExpression {
    expression :=
        DefinedRule | quotedString | CharacterRange | RegularExpressionMatch;

    bracketExpression := BracketExpression(this);

    expressionGroup := bracketExpression | expression;

    notExpression := PreFixOp('!', expressionGroup ) | expressionGroup

    repeater := PostFixOp('+', notExpression) | 
                PostFixOp('*', notExpression) | 
                PostFixOp('?', notExpression) | 
                notExpression |
                BracketExpression(this, '<', '>');

    joiner := repeater ('^' repeater)* | BracketExpression(this, '<', '>');

    alternate := joiner ('|' joiner)*;

    # each alternate has a sublist of joiner, each joiner having a sublist
    # of type repeater. the results are propogated through the rules
    list( alternate, joiner, repeater ) expressions := alternate+;

    begin := expressions;
}

# this class represents a simple (possibly private) rule with no storage
class Rule : RuleAbstract {
    # a compile time bitset which has an enum with the same names as the
    # strings it matches
    bit_set( private ) typeSpecifier;

    RuleExpression expression;

    begin := typeSpecifier name ':=' expression;
    end := terminate;
}

class SearchExpression {
}

class Attribute : RuleAbstract {
    bit_set( unique, mandatory, parent ) attributeSpecifier;

    DefinedRule storageRule;
    RuleExpression expression;
    SearchExpression search;

    begin := attributeSpecifier storageRule name 
             ( ':=' expression )? (':' search)? ;
}

inline class ClassContents {
    # attributes
    list( Rule ) simpleRules;

    # it is unique, so even though it can be matched multiple times if it is
    # set twice we are in trouble
    unique BeginRule beginRule;

    begin := (simpleRules | beginRule)*

}

class ClassAbstract {
    id name;
}

class DefinedClass {
    ClassAbstract class := id : global( rule.name = id );
    
    begin := class;
}

class Class : ClassAbstract {
    ClassContents classContents;

    abstract class Parameter {
        id name;
    }
    class CharParameter : Parameter {
        character default;
        begin := 'char' name ('=' default)?;
    }
    class StringParameter : Parameter {
        quotedString default;
        begin := 'string' name ('=' default)?;
    }
    class IntParameter : Parameter {
        integer default;
        begin := 'int' name ('=' default)?;
    }
    class ClassParameter {
        DefinedClass default;
        begin := 'class'? name ('=' default)?;
    }

    ordered_set( Parameter ) classParameters := 
        '(' Parameter ( ',' Parameter ) * ')';

    # parent makes the elements referenced in this set parents in the scope
    # TODO: Fix this to handle class parameters as well
    parent ordered_set( parentClass ) classParent;
    parentClass := Class | ;
    parent ordered_set( parentClass ) classParent := ':' parentClass (',' parentClass)* ;

    begin := 'class' classParameters? name '{' classContents;

    end := '}';
} 

class UsingStatement {
    # importFile() passed implicitly fileName type and can handle it
    fileName useFilename { importFile() };

    # TODO: take elements out of tree that do not match specifier
    list( id ) importedElements := id (',' id)*;

    begin := 'using' useFilename (importedElements);

    end := terminate;
}

# the global begin.. everything allowed in a class is allowed in the global
# namespace along with using statements (class is allowed in class contents)
begin := (ClassContents | UsingStatement) + 
