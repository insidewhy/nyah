WhitespaceNoNewlines = [ \t]+
Whitespace = [ \t\n]+
Comment = '//' UntilSkip(\n)
Identifier = [_a-zA-Z][_a-zA-Z0-9]*

// \" is like '"'
StringNode = \" self !\"* \" | \' self !\'* \'

Number = [0-9]+

SimpleNode = TextNode | HtmlNode | StringNode
Node = SimpleNode | VariableDefinition | MasterHtmlNode
HeadNode = Node | Macro
NodeChildren = Node*
HeadNodeChildren = HeadNode*

// [!,)] matches any character except , or )
HtmlArgumentValue = StringNode | [!,)]+

HtmlNodeArgument = (name:Identifier '=')? value:HtmlArgumentValue

HtmlNode {
    children = '{' NodeChildren '}'

    arguments = '(' must Joined(','?, HtmlNodeArgument) ')'

    // since children already exists as a declared member :SimpleNode will "cast"
    // it by parsing only an Node and storing it in the children member
    // (for this to work the cast type must be an expression that the type
    //  cast from would also match)
    // must expression triggers global error
    begin = marker:Identifier children |
            ( '%' must marker:Identifier arguments? |
              marker:Identifier arguments )
            ( ^ WhitespaceNoNewlines ^ children:SimpleNode | children?)
            
}

// ~ means sequence with whitespace, same as just leaving space between two
// parser but can be used to join lines
MasterHtmlNode : HtmlNode =
    '!' must marker:Identifier arguments? ~
        must(\n, "nothing allowed on line after ! node") ~
        children:Node*

// local means the variable is not stored 
// In this case it means the stored of TextNode is the same as UntilSkip...
// matched returns a parser which matches the string the parser
// variable matched
TextNode = 
    '<<' ^ local textMarker:Identifier \n UntilSkip(\n ^ matched textMarker)

Macro {
    // TODO
}

Expression = Number | StringNode

// var Expression equivalent to expression:Expression
VariableDefinition = '$' name:Identifier '=' var Expression

Global = children:HeadNodeChildren
