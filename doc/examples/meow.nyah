WhitespaceNoNewlines {
    begin = [ \t]+
}

Whitespace {
    begin = [ \t\n]+
}

Comment {
    begin = '//' UntilIncluding(\n)
}

Identifier = [_a-zA-Z][_a-zA-Z0-9]*

StringNode {
    begin = ('"' self (!'"')* '"') |
            ('\'' self (!'\'')* '\'')
}

Number {
    begin = [0-9]+
}

SimpleNode = TextNode | MasterHtmlNode | HtmlNode | StringNode
Node = SimpleNode | VariableDefinition
HeadNode = Node | Macro
NodeChildren = Node*
HeadNodeChildren = HeadNode*

HtmlArgumentValue {
    begin = (StringNode | (!',')+)
}

HtmlArgument {
    begin = ((name:Identifier '=')? value:HtmlArgumentValue)
}

HtmlNode {
    children = '{' NodeChildren '}'

    arguments = '(' Joined(',', HtmlArgument) ')'

    // since children already exists as a declared member :HtmlNode will "cast"
    // it by parsing only an Node and storing it in the children member
    // (for this to work the cast type must be an expression that the type
    //  cast from would also match)
    // must expression triggers global error
    begin = (marker:Identifier arguments? children) |
            ('%' must(marker:Identifier, "expected identifier after %") arguments? (
                ^ WhitespaceNoNewlines ^ children:SimpleNode | 
                children?))
            
}

MasterHtmlNode : HtmlNode {
    // "\" at end of line to continue statement
    begin = '!' must(marker:Identifier, "expected identifier after !") arguments  \
                must('\n', "nothing allowed on line after ! node")    \
                children:NodeChildren+
}

TextNode {
    // local means the variable is not stored as an attribute (in this case it
    // is just used in the Until object) and does not form part of the type
    // (so the type is the same as the Until (which is String) in this case
    // matched returns a parser which matches the string the parser
    // variable matched

    begin = '<<' ^ local textMarker:Identifier \n \
            UntilIncluding(\n ^ matched textMarker)
}

Macro {
    // TODO
}

Expression {
    begin = (Number | StringNode)
}

VariableDefinition {
    // var Expression equivalent to expression:Expression
    begin = '$' name:Identifier '=' var Expression
}

Global {
    begin = children:HeadNodeChildren
}
