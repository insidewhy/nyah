general modifiers:
 *  quote( 
        quoteChr[s] |  begin_quote_chr => The begining and end quotation marks
        endQuoteChr[s]                 => override end quotation mark with
                                          this/these characters
        strip                          => Strip quotes from token [default: true]
    )
     note: can also apply to an ebnf object (use escape)

 *  terminator(
        chr[s]  =>   terminate current token at this/these character(s)
    )       
    note: can also apply to an ebnf object

 *  strip(
        variable          => reference to variable to strip. usually passed in from
                             parent rule.
        char[s] |         
        str[s]  |         => [list of] thing[s] to strip out of the token
        regexp[s]
    )

 * subst(
        variable          => reference to variable to strip. usually passed in from
                             parent rule.
        match_char[s]   |         
        match_str[s]    | => [list of] thing[s] to strip out of the token
        match_regexp[s]

        subst_char[s]   |         
        subst_str[s]    | => [list of] thing[s] to replace in token
        subst_regexp[s]
    )
    List sizes of match and subst should counter balance. $\n can be used for
    backreferences as perl. 
    would like to have (?:) make a non-capturing sub-expression as perl.



Built in matching rules
-----------------------
string (matches string)
    * default modifiers : quote(");  # use termintor("\n") in most cases

integer: [0-9]+
    matches c-style integer. Adds to token table.

float:   integer.integer
    matches c-style float. Adds to token table.

number:
    matches c-style float or integer. Adds to token table.

Available via plugins
---------------------
string cIdentifier: matches c identifiers

Context variables
-----------------
$<rule>: name of rule from most enclosing scope.
$line: line number
$col:  column
$<number>: backreferences.. see subst command
