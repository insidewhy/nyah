# an ordered list that can store any of the given types
builtin class collection(types...);
bultin class list(types...) : collection(types...) {

    # commute to every element of the list
    parent;

    begin&;
    # call begin& on every element of current list ensuring all
    # mandatory conditions are valid parsing as we go
}

# can match one of any of the ids in id and stores the one which is matched
builtin class bit_set(id...);

# as above but can match more than one of the ids and has an on/off for each id
builtin class multi_bit_set(id...);

# hey poopy poop face I miss you. *Honor Me For Eva* 

# join is specialised over list
# call begin over and over until there are no more joins pushing back each
# match to the list
builtin class join(str, exp : collection);

# join is specialised over reference to list list
builtin class join(str, exp : collection&);
# match begin& for each element in the referred to list with as many joined
# elements as we have, then continue to match begin& with
# special type null for remaining parameters in the NON reference case

################################################################################
# types
################################################################################
# if this is the type of a rule then store true if it is matched, else false
type bool;

# flatten the elements out into a string
type string;

# convert string arguments to corresponding numbers
type int;
type long;
type float;
type double;

################################################################################
# functions
################################################################################
# parse file with given extension using current language
builtin function parse(extension = '');

# test that `parent' is a parent of `child'
bultin function parent_child(parent, child);
