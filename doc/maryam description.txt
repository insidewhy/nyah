This document serves as an introduction to the object oriented AST generating
parser generator `Maryam'.

It is assumed the reader has at least some familiarity with an object oriented
language, and at least a basic knowledge of EBNF. Regular expressions would
also help.

* Beginning a grammar

grammar "Preprocessor";

This specifies that we are now begining a grammar called "Preprocessor"

* A rule

rule := '<' string '>';

Here we introduce a few things. In this case rule is in the global namespace
and can be used from anywhere. The '<' and the '>' are string literals. They
refer to tokens passed from the tokenizer/lexer (this is automatically
constructed from a table of all use literals and builtins). Here `string' is a
built-in rule. A pre-existing rule which matches any string of characters. `;'
terminates the rule.

* Namespaces and classes.

global {
    rule := '<' string '>';
}

This is the same as putting a rule in the main part of a grammar but it might
be preferrable to improve formatting and code readability.

* Classes and constructors

abstract class statement {
    statement := ^'#';
}

This creates the abstract class `statement'. It consists of a `constructor' rule
`statement'.  This is similar to a constructor method in C++. A classes
constructor must match the string being parsed in order for the class to be
matched (classes can be used like rules as you will see later). The bare
character ^ means this rule only matches at the begining of the document (i.e.
there is no whitespace before it). It acts as an anchor as in regular
expressions the same as the anchor $ which matches after the last character.

abstract classes are helper classes that can not be used to create a parse
match, and must be used via proper classes and inheritance.

# Operations, the - operator, and more EBNF ideas.

ppValuePart { subst(/\s+|\n+/," ") } := . - ("\n" | '\') ;

As this is matched the rule has the operation "subst(<regular expression>,
<string>)" applied to it. As you will see later rules can be used as variable
types to store data and if this rule is used as a variable type the variable's
value will not be that of the string that matched but the string after the
subst operation has been applied. Curly brackets are used to delimit operators
and can appear on the RHS of a rule definition (they apply to the whole rule
when it is matched), or to an element in the LHS (they will be applied to the
elements within the rule matched after the whole rule is matched).

ppValuePart is a rule which matches "." (any character as for regular
expressions) except (the minus operator), "\n" a newline or (the | operator) a 
backslash (grouped into a tuple with brackets).

* The ! operator

`! rule' is a shorthand for `. - rule'. The RHS of ppValue part could be written:

! ("\n" | '\');

** Built in functions introduction

subst is a built-in function which operates on a string of matched text and
modifies it in some way. The function's first argument is a string and Maryam
knows to automatically pass in the string of the matched rule to this value.
The remaining two values are passed in of type regular expression and string.
subst is overloaded to be able to take many useful arguments. In this case the
first match of the regular expression \s+|\n+ will be replaced by the string "
". (substall can be used to substitute all such arguments and would be more
accurate for a c-preprocessor).

* Comments

# ensure ## token remains seperated by a space in resulting string and "##"
# become token

`#' is used as a comment character. / was not considered for comment use
because of it's importance in being used as a regular expression type
delimeter in Maryam.

* EBNF iterative quantifiers and conjunction

ppValue := ppValuePart ("##" ppValuePart)*;

Parantheses are used for grouping as described earlier, and the * after the 
group acts as a quantifier as it does in EBNF or regular expressions. This
means that ppValuePart can be matched over and over again and will constitute
to the value of the rule "ppValue". "##" is followed by a space then
ppValuePart meaning both "##" and the rule ppValuePart must match in sequence
for the rule to be matched.

* Class attributes and inheritence

abstract class definitionBase : statement {
    string name;

    definitionBase := "define" name;
}

definitionBase uses the class described earlier "statement" as it's parent.
The constructor of a statement must match before the constructor of the child
class. This class also introduces an attribute `name' of type
string. The constructor uses the attribute name as one EBNF
statement in the constructor. In this case if the *type* of the attribute
matches then the string which matched this type is stored in the attribute.

* Inheriting attributes and using rules as variable types.

class varDefinition : definitionBase {
    ppValue varName;
    varDefinition := varName?;
}

The rule ppValue is used as the type of the variable `varName'. In this case
when it is used in varDefinition the variable only matches what the rule would
match. The string which matched the value is stored in the variable, unless
the underlying data type is numerical or can be made numerical by an operation
it has attached to it. A rule is very similar to a class, it is basically
shorthand for a class which only has a constructor and no attributes.

varDefinition inherits from definitionBase, and therefore the attributes of
definitionBase are also part of the new type varDefinition, and will be set
when the constructor of definitionBase is matched (recall it has to for a
child class to match).

* Completing some more of the c-preprocessor

For sake of completeness here are the classes for undef 

class varUndefinition : statement {
    string name;
    varUndefinition := "undef" name;
}

* Containers

abstract class parameterList {
    # cIdentifier is sourced from some maryam library files, it's easy to 
    # guess what it matches
	vector<cIdentifier> parameters;
	parameterList := ^'(' (parameters (',' parameters)* ')';
}

The class parameterList has an attribute vector<cIdentifier> parameters. This
makes the type parameters a container of many values. Whenever the rule
parameters matches the value it matches becomes another element in the
container. In this case `(apple, monkey)' would become the container 
`{ apple , monkey }', a container of two c-identifiers.

In this case a vector is used, list and set (as per stl list and set), and
hash (as per the TR1 boost Hash) can also be used.

Note here that "^" is used but can't possibly match at the begining of the
line as the parent class rule must match first. In this case ^ means that
there must be no whitespace between the last token of the parent class and the
first token of this class.

* Object composition 

abstract class definitionBase : statement {
    string name;

    definitionBase := "define" name;
}

class varDefinition : definitionBase {
    ppValue varName;
    varDefinition := varName?;
}

class functionDefinition : definitionBase {
	parameterList parameters;

    functionDefinition := parameters ppValuePart;
}

The attribute `parameters' has the type parameterList which
was a class we defined earlier. In this case the parameterList object becomes
a node under the functionDefinition in the tree (and are related via foreign
keys in the database). For the object of type parameterList to match the
constructor of parameters must match, and all the variables (and possible
subnodes via further nesting) will be assigned and accessable through the
parameters attribute. This is very different from the case of class
inheritence, where we create a new bigger table from the conjunction with parent
tables, and both are useful techniques for creating parsers.

* Modifiers

A modifier can be used to make fine tuned adjustments to the way a rule
matches.

string s [ quote('"') ];

Is a shorthand for 

s := '"' string '"';

* The join modifier

string joinRule[ join(" ") ];
directories := '/' ? (joinRule '/')* '/'?

In this case join matches multiple times but joinRule will contain the result
of all the matches joined with the string supplied.

* Directives

Directives are special instructions which can be sent to maryam during the
parse stage. New directives can be implemented with plugins. They appear after
rules and apply as soon as this match is valid.

* Default values and directives modifying attributes.

class include : statement {
    string includeFile;
    bool   isSystemHeader = false;

    sysHeaderIncludeStr{ isSystemHeader = true } := '<' includeFile '>';
    generalIncludeStr := '"' includeFile '"';

    include := 'include' (sysHeaderIncludeStr | generalIncludeStr);
}

In the include class the attribute isSystemHeader is set to false by default
with the `=' operator (`:= is the rule assignment operator'). However if the 
attribute sysHeaderIncludeStr is matched then the directive will be invoked and 
will make this value true.

* The parse directive

The following directive instructs maryam to parse to start parsing a given
file.

importMatch := 'import' string{ parse() };

The parse directive takes on argument, a string matching the file to parse.
Maryam will by default fill it in from the rule the directive applies to,
which in this case is the string after `import'. The directive is executed
when the enclosing rule is matched and considered valid. environment variables
and configuration files are used to determine the directory search path.

* Using the parse directive

The gnu cpp file includes directives that wrap parse and make the maryam follow
include files using directives from the c-preprocessor (passed through the -I
argument to maryam).

Revisiting the case of include we can enhance it to make maryam open and parse
another file using these two directives.

class include : statement {
    string includeFile;
    bool   isSystemHeader = false;

    sysHeaderInclude { isSystemHeader = true; gccSysParse(includeFile) } 
                      := '<' includeFile '>';

    # includeFile is auto-passed as first argument to gccParse
    generalIncludeStr := '"' includeFile{ gccParse() } '"';

    include := 'include' (  sysHeaderInclude | generalIncludeStr );
}

* Searching the AST with the search modifier

In the c-preprocessor when we include the result of the include may be a
preprocessor directive e.g.

#define NICEFILE  "<nicefile.hpp>"
#include NICEFILE

When we include NICEFILE we want to use the most recent value of NICEFILE from
the c-preprocessor AST built up so far. In order to do that we need to look up
the value of the symbol `NICEFILE' which should be stored in a rule or string
somewhere backwards through the scope. There are a number of ways to access
values that already lie in the tree. It is possible to correct the previous
definition of #include.

# recall these
abstract class definitionBase : statement {
    string name;

    definitionBase := "define" name;
}

class functionDefinition : definitionBase {
	parameterList parameters;

    functionDefinition := parameters ppValuePart;
}

class varDefinition : definitionBase {
    ppValue value;
    varDefinition := value?;
}

class varUndefinition : statement {
    string name;
    varUndefinition := "undef" name;
}

# the improved implementation starts
class include : statement {
    string includeFile;

    bool   isSystemHeader = false;

    sysHeaderInclude { isSystemHeader = true } 
                      := ('<' includeFile '>')
                         { gccSysParse( includeFile ) };

    generalInclude    := ('"' includeFile '"' )
                         { gccParse( includeFile ) };

    
    # : begins the search statement
    evalStm := cIdentifier : reverseTreeScope :
        error(varUndefinition.name == cIdentifier, 
              "including undefined identifier $cIdentifier");
        return(varDefinition.name == cIdentifier,
               varDefinition.value);
        noMatchError("#include of non-existent preprocessor token $cIdentifer");

    treeSearchInclude := generalInclude(evalStm) | sysHeaderInclude(evalStm);

    include := 'include' (  sysHeaderInclude  | generalInclude |
                            treeSearchInclude );
}

I mentioned before that a rule is like a class with only a constructor. In
this case the rule `treeSearchInclude', constructs the attributes generalInclude
and sysHeaderInclude with the result of the rule evalStm.

evalStm matches a cIdentifier and then applies the search treeScope to fill in
the value of rule with the result of the search.

The first argument is a search type, in this case `backwardsTreeScope'

`reverseTreeScope' searches backwards through the scope to match the various
predicates attached to it. In this case there are two predicates.

The first is an error predicate. If the predicate: 
`varUndefinition.name == cIdentifier' is true, then the error condition 
argument is raised and the search has failed. Variables of the form $<name>
are expanded to the string which matched the rule $<name>.

IMPORTANT: Errors are only reported if the parsed string is actually matched, 
whereas the lookup happens when the variable is first accessed.

The second case is a return statement, which returns a given values if the
first argument is true. In this case the resulting varDefinition's value will
be substituted with the contents of rule that called the scope.

If no match is found we want to signal an error condition so noMatchError is
used to raise an error if no match is found.

* Advanced search statements

It is possible to modify attributes of the entire enclosing class with search
statements. Take the following rule which matches any c-preprocessor token.

class cppTokenMatch {
    
    definitionBase token;
    cppTokenMatch := cIdentifier : reverseTreeScope :
                                        success(definitionBase.name == cIdentifier,
                                                token = definitionBase)
}

definitionBase is an abstract type, so can be used to point to any of the
subclasses (class composition is always performed using references in memory
and the database).

The success statement in the reverse tree scope simply indicates a succesful
match if the predicate is true. The second argument is an optional statement
to execute if the predicate matches. In this case it is used to assign the
reference to token.

NOTE: abstract class references can be implemented with virtual functions and
pointers or multi-indexing methods, both have their drawbacks and advantages 
but are slower than general reference indexes so the imposition of this should 
be considered when using references to abstract classes.

* Improving the include object yet again

When including the result of a preprocessor token it would be useful to store a
handle to c-preprocessor definition that the include statement received the
file value from. This can be done through the attribute includeToken as shown
below.

class include : statement {
    string includeFile;
    varDefinition includeToken;  # reference to rule which built this
    bool   isSystemHeader = false;

    sysHeaderInclude { isSystemHeader = true } 
                      := ('<' includeFile '>')
                         { gccSysParse( includeFile ) };

    generalInclude    := ('"' includeFile '"' )
                         { gccParse( includeFile ) };

    
    # : begins the search statement
    evalStm := cIdentifier : reverseTreeScope :
        error(varUndefinition.name == cIdentifier, 
              "including undefined identifier $cIdentifier");
        return(varDefinition.name == cIdentifier,
               varDefinition.value,
               includeToken = varDefinition); # note new argument
        noMatchError("#include of non-existent preprocessor token $cIdentifer");

    treeSearchInclude := generalInclude(evalStm) | sysHeaderInclude(evalStm);

    include := 'include' (  sysHeaderInclude  | generalInclude |
                            treeSearchInclude );
}

A third optional argument to return is a statement to execute on success
before returning, in this case the matching varDefinition is assigned to the
includeToken reference attribute.

* Rule parameters and multiple inheritence

It would be nice to factor out the evalStm functionality into a base class as
it is useful generic functionality. In its current form it is not suitable
for this purpose as the error messages are specific. By factoring out these
elements into parameters the rule can be used in subclasses. 

class tokenStore {
    varDefinition includeToken;  # reference to token rule

    evalStm := cIdentifier : reverseTreeScope :
                    return(varDefinition.name == cIdentifier,
                           varDefinition.value,
                           includeToken = varDefinition);

    # overload and append err messages, +reverseTreeScope is used to append 
    # additional rules to the matcher
    evalStm(undefMsg, notfoundMsg) := evalStm : +reverseTreeScope :
        error(varUndefinition.name == cIdentifier, 
              undefMsg);
        noMatchError(notfoundMsg);
}


class include : statement, tokenStore {
    string includeFile;
    bool   isSystemHeader = false;

    sysHeaderInclude { isSystemHeader = true } 
                      := ('<' includeFile '>')
                         { gccSysParse( includeFile ) };

    generalInclude    := ('"' includeFile{ } '"' )
                         { gccParse( includeFile ) };

    evalStm := evalStm(undefMsg = "including undefined identifier $cIdentifier",
                       notfoundMsg = "#include of non-existent preprocessor token $cIdentifer");
    
    treeSearchInclude := generalInclude(evalStm) | sysHeaderInclude(evalStm);

    include := 'include' (  sysHeaderInclude  | generalInclude |
                            treeSearchInclude );
}

Now evalStm inherits from both statement and tokenStore (in the generated code
multiple inheritance is used for this purpose). evalStm overloads the
tokenStore parent version by calling it with the relevant error message
strings. notfoundMsg relies on matching the parent rule's $cIdentifier token,
but maryam can detect this through the constructor call. evalStm can be called
using two different syntaxes:

`evalStm(arg1, arg2)', or `evalStm(undefMsg = arg1, notfoundMsg = arg2)'.

* Inline classes and scope issues

It would be useful if #ifdef statements that evaluated falsely would keep
tokens withen the statement from affecting the scope of rules found after the
ifdef statement concludes.

For example

#ifdef 0
#define MUNCH
#endif

#ifdef MUNCH
#define THIS_SHOULD_NOT_AFFECT_THE_SCOPE
#endif

Then a simple understanding of the c-preprocessor shows that
THIS_SHOULD_NOT_AFFECT the scope should follow it's name. To ensure this
happens #ifdef statements can raise the scope when they do not evaluate to
ensure they are not found in tree searches, and flatten to the enclosing tree
otherwise. For this purpose an inline class can be used. An inline class does
not create a new node in the tree by default, as most classes do, but using
the direct "raiseScope", it can acheive this purpose artificially when the
symbol is undefined. 

inline class ifdefStm : statement, tokenStore {
    bool undefined = false;

    evalStm ifdefResult := evalStm : +reverseTreeScope :
        noMatchError(undefined = true)
        success(varUndefinition.name == cIdentifier, 
                undefined = true);

    ifdefStm := ^ "ifdef" ifdefResult{ if (undefined, raiseScope())};
}

ifdefStm overrides evalStm to modify a status variable if the definition is
not found.

This makes sure the scope is raised when the symbol is not defined. The first
argument to `raiseScope' is a reference to a class to push onto the scope. By
default it passes `this', a reference to the class itself.

Suggested Music: Mogwai - Ten Rapid
