This document serves as an introduction to the object oriented AST generating
parser generator `Maryam'.

It is assumed the reader has at least some familiarity with an object oriented
language, and at least a basic knowledge of EBNF. Regular expressions would
also help.

* Beginning a grammar

grammar "Preprocessor";

This specifies that we are now begining a grammar called "Preprocessor"

* A rule

rule := '<' string '>';

Here we introduce a few things. In this case rule is in the global namespace
and can be used from anywhere. The '<' and the '>' are string literals. They
refer to tokens passed from the tokenizer/lexer (this is automatically
constructed from a table of all use literals and builtins). Here `string' is a
built-in rule. A pre-existing rule which matches any string of characters. `;'
terminates the rule.

* Namespaces and classes.

global {
    rule := '<' string '>';
}

This is the same as putting a rule in the main part of a grammar but it might
be preferrable to improve formatting and code readability.

* Classes and constructors

statement {
    statement := ^'#';
}

This creates the class called "statement". It consists of a `constructor' rule
`statement'.  This is similar to a constructor method in C++. A classes
constructor must match the string being parsed in order for the class to be
matched (classes can be used like rules as you will see later). The bare
character ^ means this rule only matches at the begining of the document (i.e.
there is no whitespace before it). It acts as an anchor as in regular
expressions the same as the anchor $ which matches after the last character.

# Operations, the - operator, and more EBNF ideas.

ppValuePart { subst(/\s+|\n+/," ") } := . - ("\n" | '\') ;

As this is matched the rule has the operation "subst(<regular expression>,
<string>)" applied to it. As you will see later rules can be used as variable
types to store data and if this rule is used as a variable type the variable's
value will not be that of the string that matched but the string after the
subst operation has been applied. Curly brackets are used to delimit operators
and can appear on the RHS of a rule definition (they apply to the whole rule
when it is matched), or to an element in the LHS (they will be applied to the
elements within the rule matched after the whole rule is matched).

ppValuePart is a rule which matches "." (any character as for regular
expressions) except (the minus operator), "\n" a newline or (the | operator) a 
backslash (grouped into a tuple with brackets).

* The ! operator

`! rule' is a shorthand for `. - rule'. The RHS of ppValue part could be written:

! ("\n" | '\');

** Built in functions introduction

subst is a built-in function which operates on a string of matched text and
modifies it in some way. The function's first argument is a string and Maryam
knows to automatically pass in the string of the matched rule to this value.
The remaining two values are passed in of type regular expression and string.
subst is overloaded to be able to take many useful arguments. In this case the
first match of the regular expression \s+|\n+ will be replaced by the string "
". (substall can be used to substitute all such arguments and would be more
accurate for a c-preprocessor).

* Comments

# ensure ## token remains seperated by a space in resulting string and "##"
# become token

`#' is used as a comment character. / was not considered for comment use
because of it's importance in being used as a regular expression type
delimeter in Maryam.

* EBNF iterative quantifiers and conjunction

ppValue := ppValuePart ("##" ppValuePart)*;

Parantheses are used for grouping as described earlier, and the * after the 
group acts as a quantifier as it does in EBNF or regular expressions. This
means that ppValuePart can be matched over and over again and will constitute
to the value of the rule "ppValue". "##" is followed by a space then
ppValuePart meaning both "##" and the rule ppValuePart must match in sequence
for the rule to be matched.

* Class attributes and inheritence

definitionBase : statement {
    string definitionName;

    definitionBase := "define" definitionName;
}

definitionBase uses the class described earlier "statement" as it's parent.
The constructor of a statement must match before the constructor of the child
class. This class also introduces an attribute `definitionName' of type
string. The constructor uses the attribute definitionName as one EBNF
statement in the constructor. In this case if the *type* of the attribute
matches then the string which matched this type is stored in the attribute.

* Inheriting attributes and using rules as variable types.

varDefinition : definitionBase {
    ppValue varName;
    varDefinition := varName?;
}

The rule ppValue is used as the type of the variable `varName'. In this case
when it is used in varDefinition the variable only matches what the rule would
match. The string which matched the value is stored in the variable, unless
the underlying data type is numerical or can be made numerical by an operation
it has attached to it. A rule is very similar to a class, it is basically
shorthand for a class which only has a constructor and no attributes.

varDefinition inherits from definitionBase, and therefore the attributes of
definitionBase are also part of the new type varDefinition, and will be set
when the constructor of definitionBase is matched (recall it has to for a
child class to match).

* Completing some more of the c-preprocessor

For sake of completeness here are the classes for undef 

varUndefinition : statement {
    string varName;
    varUndefinition := "undef" varName;
}

* Containers

parameterList {
    # cIdentifier is sourced from some maryam library files, it's easy to 
    # guess what it matches
	vector<cIdentifier> parameters;
	parameterList := ^'(' (parameters (',' parameters)* ')';
}

The class parameterList has an attribute vector<cIdentifier> parameters. This
makes the type parameters a container of many values. Whenever the rule
parameters matches the value it matches becomes another element in the
container. In this case `(apple, monkey)' would become the container 
`{ apple , monkey }', a container of two c-identifiers.

In this case a vector is used, list and set (as per stl list and set), and
hash (as per the TR1 boost Hash) can also be used.

* Default values and operators modifying attributes.

include : statement {
    string includeFile;
    bool   systemHeaderInclude = false;

    sysHeaderIncludeStr { systemHeaderInclude = true } := '<' includeFile '>';
    generalIncludeStr := '"' includeFile '"';


    include := 'include' (sysHeaderIncludeStr | generalIncludeStr);
}

In the include class systemHeaderInclude is by default set to false with the
`=' operator (`:= is the rule assignment operator'). However if the attribute
sysHeaderIncludeStr is matched then the operation will change this value to
true.

* Object composition 
definitionBase : statement {
    string definitionName;

    definitionBase := "define" definitionName;
}

varDefinition : definitionBase {
    ppValue varName;
    varDefinition := varName?;
}

functionDefinition : definitionBase {
	parameterList parameters;

    functionDefinition := parameters ppValuePart;
}

The attribute `parameters' has the type parameterList which
was a class we defined earlier. In this case the parameterList object becomes
a node under the functionDefinition in the tree (and are related via foreign
keys in the database). For the object of type parameterList to match the
constructor of parameters must match, and all the variables (and possible
subnodes via further nesting) will be assigned and accessable through the
parameters attribute. This is very different from the case of class
inheritence, where we create a new bigger table from the conjunction with parent
tables, and both are useful techniques for creating parsers.

* Modifiers

A modifier can be used to make fine tuned adjustments to the way a rule
matches.

string s [ quote('"') ];

Is a shorthand for 

s := '"' string '"';

* The join modifier

string joinRule[ join(" ") ];
directories := '/' ? (joinRule '/')* '/'?

In this case join matches multiple times but joinRule will contain the result
of all the matches joined with the string supplied.

* Directives, The parse directive.

Directives are special instructions which can be sent to maryam during the
parse stage. New directives can be implemented with plugins.

The following directive instructs maryam to parse to start parsing a given
file.

importMatch := 'import' string< parse() >;

The parse directive takes on argument, a string matching the file to parse.
Maryam will by default fill it in from the rule the directive applies to,
which in this case is the string after `import'. The directive is executed
when the enclosing rule is matched and considered valid. environment variables
and configuration files are used to determine the directory search path.

* Using the parse directive

The gnu cpp file includes directives that wrap parse and make the maryam follow
include files using directives from the c-preprocessor (passed through the -I
argument to maryam).

Revisiting the case of include we can enhance it to make maryam open and parse
another file using these two directives.

include : statement {
    string includeFile;
    bool   systemHeaderInclude = false;

    sysHeaderIncludeStr { systemHeaderInclude = true } 
                      := ('<' includeFile '>')
                         < gccSysParse( includeFile ) >;

    generalIncludeStr := ('"' includeFile '"' )
                         < gccParse( includeFile ) >;


    include := 'include' (  sysHeaderIncludeStr  | generalIncludeStr );
}

* Searching the AST with the search directive

In the c-preprocessor when we include the result of the include may be a
preprocessor directive e.g.

#define NICEFILE  "<nicefile.hpp>"
#include NICEFILE

When we include NICEFILE we want to use the most recent value of NICEFILE from
the c-preprocessor AST built up so far. In order to do that we need to look up
the value of the symbol `NICEFILE' which should be stored in a rule or string
somewhere backwards through the scope. There are a number of ways to access
values that already lie in the tree. It is possible to correct the previous
definition of #include.

# recall these
definitionBase : statement {
    string definitionName;

    definitionBase := "define" definitionName;
}

functionDefinition : definitionBase {
	parameterList parameters;

    functionDefinition := parameters ppValuePart;
}

varDefinition : definitionBase {
    ppValue value;
    varDefinition := value?;
}

varUndefinition : statement {
    string varName;
    varUndefinition := "undef" varName;
}

# the improved implementation starts
include : statement {
    string includeFile;

    bool   systemHeaderInclude = false;

    sysHeaderInclude { systemHeaderInclude = true } 
                      := ('<' includeFile '>')
                         < gccSysParse( includeFile ) >;

    generalInclude    := ('"' includeFile '"' )
                         < gccParse( includeFile ) >;

    
    # : begins the search statement
    evalStm := cIdentifier : reverseTreeScope(
        error(varUndefinition.definitionName == cIdentifier, 
              "including undefined identifier $cIdentifier");
        return(varDefinition.definitionName == cIdentifier,
               varDefinition.value);
    );

    treeSearchInclude := generalInclude(evalStm) | sysHeaderInclude(evalStm);

    include := 'include' (  sysHeaderInclude  | generalInclude |
                            treeSearchInclude);
}

I mentioned before that a rule is like a class with only a constructor. In
this case the rule `treeSearchInclude', constructs the attributes generalInclude
and sysHeaderInclude with the result of the rule evalStm.

evalStm matches a cIdentifier and then applies the search treeScope to fill in
the value of rule with the result of the search.

The first argument is a search type, in this case `backwardsTreeScope'

`reverseTreeScope' searches backwards through the scope to match the various
predicates attached to it. In this case there are two predicates.

The first is an error predicate. If the predicate: 
`varUndefinition.definitionName == cIdentifier' is true, then the
error condition argument is raised and the search has failed.

The second case is a return statement, which returns a given values if the
first argument is true. In this case the resulting varDefinition's value will
be substituted with the contents of rule that called the scope.

By default if no match is found an error signal is raised. This behaviour can
be altered with the "noMatch()" predicate.

* Affecting the parser at parse at parse time.

TODO

Suggested Music: Mogwai - Ten Rapid
