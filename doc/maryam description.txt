This document serves as an introduction to the object oriented AST generating
parser generator `Maryam'.

It is assumed the reader has at least some familiarity with an object oriented
language, and at least a basic knowledge of EBNF. Regular expressions would
also help.

* Beginning a grammar

grammar "Preprocessor";

This specifies that we are now begining a grammar called "Preprocessor"

* A rule

rule := '<' string '>';

Here we introduce a few things. In this case rule is in the global namespace
and can be used from anywhere. The '<' and the '>' are string literals. They
refer to tokens passed from the tokenizer/lexer (this is automatically
constructed from a table of all use literals and used built-ins). Here
`string' is a built-in rule that matches any string of characters. `;'
terminates the rule.

* Namespaces and classes.

global {
    rule := '<' string '>';
}

This is the same as putting a rule in the main part of a grammar but it might
be preferrable to improve formatting and code readability.

* Classes and constructors

abstract class statement {
    statement := ^'#';
}

This creates the abstract class `statement'. It consists of a `constructor' rule
`statement'.  This is similar to a constructor method in C++. A class'
constructor must match the string being parsed in order for the class to be
matched (classes can be used like rules as you will see later). The bare
character ^ means this rule only matches at the begining of the document (i.e.
there is no whitespace before it). It acts as an anchor as in regular
expressions the same as the anchor $ which matches after the last character.

abstract classes are helper classes that can not be used to create a parse
match, and must be used via proper classes and inheritance.

* The `!' and `-' operators, representing strings.

C-preprocessor strings have the format "string" or <string>, where string can
be any character except the string terminator or a newline. These formats are
matched respectively by the rules cppString and cppSysInclude:
the two string cases respectively:

cppString     := '"' (. - ("\n" | '"')) '"';

`.' matches any character as it does for regular expressions. By applying the
- operator the entire grouping will match any character except for the match
  on the right hand side of the `-' operator. 

cppSysInclude := '<' (! ("\n" | '>')) '>';`! rule' is a synonym for 

`! rule' is synonymous with `(. - rule)'. This shorthand has been used to
write the cppSysInclude rule above.

* Directives, the subst and assign directives.

string macroBody { subst(/\s+|\n+/," ") } := ("\\\n" $ { assign("") } | ! "\n")+;

As this is matched the rule has the operation "subst(<regular expression>,
<string>)" applied to it. As you will see later rules can be used as variable
types to store data and if this rule is used as a variable type the variable's
value will not be that of the string that matched but the string after the
subst operation has been applied. Curly brackets are used to enclose
directives and follow the rule or group which causes the directive to be
executed on match.

if a directive appears on the LHS of a rule initilisation is applies to the 
whole rule, e.g. the following rules are synonymous:

rule                     := ( <sub elements> ) { <directive> };
sameRule { <directive> } := <sub elements>;

`subst' is a built-in directive which operates on a string of matched text and
modifies it in some way. The function's first argument is a string and Maryam
knows to automatically pass in the string of the matched rule to this value.
The remaining two values are passed in of type regular expression and string.
subst is overloaded to be able to take many useful arguments. For macroBody 
the first match of the regular expression \s+|\n+ will be replaced by the 
string " ". (substAll can be used to substitute all such arguments and would 
be more accurate for a c-preprocessor).

The `assign' directive's first argument is a reference to a string to modify,
again in this case automatically passed by maryam. It assigns the value of the
second argument to this reference. In this case it causes "\\n" at the end of
a line to be replaced with the empty string.

* Enhancing the string matches with directives.

cppString     { strip('"') }             := ('"' (. - ("\n" | '"')) '"');
cppSysInclude { strip('<'), strip('>') } := ('<' (! ("\n" | '>')) '>');

* Comments

# ensure ## token remains seperated by a space in resulting string and "##"
# become token

`#' is used as a comment character. / was not considered for comment use
because of it's use as a regular expression type delimeter in Maryam.

* EBNF iterative quantifiers and conjunction

ppValue := macroBody ("##" macroBody)*;

Parantheses are used for grouping as described earlier, and the * after the 
group acts as a quantifier as it does in EBNF or regular expressions. This
means that macroBody can be matched over and over again and will constitute
to the value of the rule "ppValue". "##" is followed by a space then
macroBody meaning both "##" and the rule macroBody must match in sequence
for the rule to be matched.

* Class attributes and inheritence

abstract class definitionBase : statement {
    string name;

    definitionBase := "define" name;
}

definitionBase uses the class described earlier "statement" as it's parent.
The constructor of a statement must match before the constructor of the child
class. This class also introduces an attribute `name' of type string. The 
constructor uses the attribute name as one EBNF statement in the constructor. 
In this case if the *type* of the attribute matches then the string which 
matched this type is stored in the attribute.

* Inheriting attributes and using rules as variable types.

class varDefinition : definitionBase {
    ppValue varName;
    varDefinition := varName?;
}

The rule ppValue is used as the type of the variable `varName'. In this case
when it is used in varDefinition the variable only matches what the rule would
match. The string which matched the value is stored in the variable, unless
the underlying data type is numerical or can be made numerical by an operation
it has attached to it. A rule is very similar to a class, it can be considered
as shorthand for a class that only has a constructor and no attributes.

varDefinition inherits from definitionBase, and therefore the attributes of
definitionBase are also part of the new type varDefinition, and will be set
when the constructor of definitionBase is matched (recall it has to for a
child class to match).

* Completing some more of the c-preprocessor

For sake of completeness here are the classes for undef 

class varUndefinition : statement {
    string name;
    varUndefinition := "undef" name;
}

* Containers

abstract class parameterList {
    # cIdentifier is sourced from some maryam library files, it's easy to 
    # guess what it matches
	vector<cIdentifier> parameters;
	parameterList := ^'(' (parameters (',' parameters)* ')';
}

The class parameterList has an attribute `parameters' of type 
`vector<cIdentifier>'. This makes the type parameters a container of many 
values. Whenever the rule parameters matches the value it matches becomes 
another element in the container. In this case `(apple, monkey)' would become 
the container `{ apple , monkey }', a container of two c-identifiers.

In this case a vector is used, list and set (as per stl list and set), and
hash (as per the TR1 boost Hash) can also be used.

Note here that "^" is used but can't possibly match at the begining of the
line as the parent constructor rule must match first. In this case ^ means that
there must be no whitespace between the last token of the parent class and the
first token of this class.

* Object composition 

abstract class definitionBase : statement {
    string name;

    definitionBase := "define" name;
}

class varDefinition : definitionBase {
    ppValue varName;
    varDefinition := varName?;
}

class functionDefinition : definitionBase {
	parameterList parameters;

    functionDefinition := parameters macroBody;
}

The attribute `parameters' has the type parameterList which
was a class we defined earlier. In this case the parameterList object becomes
a node under the functionDefinition in the tree (and are related via foreign
keys in the database). For the object of type parameterList to match the
constructor of parameters must match, and all the variables (and possible
subnodes via further nesting) will be assigned and accessable through the
parameters attribute. This is very different from the case of class
inheritence, where we create a new bigger class from the conjunction with 
parent classes, and both are useful techniques for creating parsers.

* Modifiers

A modifier can be used to make fine tuned adjustments to the way a rule
matches.

string s [ quote('"') ];

Is a shorthand for 

s := '"' string '"';

* The join modifier

string joinRule[ join(" ") ];
directories := '/' ? (joinRule '/')* '/'?

In this case join matches multiple times but joinRule will contain the result
of all the matches joined with the string supplied.

* Default values and using directives to modify attributes.

class include : statement {
    string includeFile;
    bool   isSystemHeader = false;

    include := 'include' (includeFile(cppSysInclude{isSystemHeader = true}) 
                          | includeFile(cppString));
}

I mentioned before that a rule is like a class with only a constructor. In
this case the rule `cppSysInclude', constructs the attribute includeFile with
the result of the cppSysInclude or cppString temporary rules (maryam will
optimise the copy construction out in this case and apply the rule directly to
the string).

In the include class the attribute isSystemHeader is set to false by default
with the `=' operator (`:= is the rule assignment operator'). However if the 
attribute sysHeaderIncludeStr is matched then the directive will be invoked and 
will make this value true.

* The parse directive

The following directive instructs maryam to parse to start parsing a given
file.

# this has nothing to do with c-preprocessors
importMatch := 'import' string{ parse() };

The parse directive takes on argument, a string matching the file to parse.
Maryam will by default fill it in from the rule the directive applies to,
which in this case is the string after `import'. The directive is executed
when the enclosing rule is matched and considered valid. Environment variables
and configuration files are used to determine the directory search path.

* Using the parse directive

The gnu cpp file includes directives that wrap parse and make the maryam follow
include files using directives from the c-preprocessor (passed through the -I
argument to maryam, as they would be to cpp).

Revisiting the case of include we can enhance it to make maryam open and parse
another file using these two directives.

class include : statement {
    string includeFile;
    bool   isSystemHeader = false;

    sysHeaderInclude := includeFile( cppSysInclude { sSystemHeader = true; gccSysParse() } );
    generalInclude   := includeFile( cppString     { gccParse() } );

    include := 'include' (  sysHeaderInclude | generalIncludeStr );
}

* Searching the AST with the search modifier

In the c-preprocessor when we include the result of the include may be a
preprocessor directive e.g.

#define NICEFILE  "<nicefile.hpp>"
#include NICEFILE

When we include NICEFILE we want to use the most recent value of NICEFILE from
the c-preprocessor AST built up so far. In order to do that we need to look up
the value of the symbol `NICEFILE' which should be stored in a rule or string
somewhere backwards through the scope. There are a number of ways to access
values that already lie in the tree. It is possible to correct the previous
definition of #include.

# recall these
abstract class definitionBase : statement {
    string name;

    definitionBase := "define" name;
}

class functionDefinition : definitionBase {
	parameterList parameters;

    functionDefinition := parameters macroBody;
}

class varDefinition : definitionBase {
    ppValue value;
    varDefinition := value?;
}

class varUndefinition : statement {
    string name;
    varUndefinition := "undef" name;
}

# the improved implementation starts
class include : statement {
    string includeFile;
    bool   isSystemHeader = false;

    sysHeaderInclude := includeFile( cppSysInclude{ sSystemHeader = true; gccSysParse() } );
    generalInclude   := includeFile( cppString { gccParse() } );
    
    # : begins the search statement
    evalStm := cIdentifier : reverseTreeScope( 
        varUndefinition.name == cIdentifier : error("including undefined identifier $cIdentifier");
        varDefinition.name == cIdentifier   : return(varDefinition.value);
        noMatch                             : error("#include of non-existent
                                                    preprocessor token $cIdentifer"));

    treeSearchInclude := generalInclude(evalStm) | sysHeaderInclude(evalStm);

    include := 'include' (  sysHeaderInclude  | generalInclude |
                            treeSearchInclude );
}

evalStm matches a cIdentifier and then applies the search treeScope to fill in
the value of rule with the result of the search.

The first argument is a search type, in this case `reverseTreeScope'

`reverseTreeScope' searches backwards through the scope to match the various
predicates attached to it. In this case there are two predicates.

The first is an error predicate. If the predicate: 
`varUndefinition.name == cIdentifier' is true, then the error condition 
argument is raised and the search has failed. Variables of the form $<name>
are expanded to the string which matched the rule $<name>.

IMPORTANT: Errors are only reported if the parsed string is actually matched, 
whereas the lookup happens when the variable is first accessed.

The second case is a return statement, which returns a given value if the
first argument is true. In this case the resulting varDefinition's value will
be substituted with the contents of the string returned.

If no match is found we want to signal an error condition so noMatch is
used to raise an error if no match is found.

* Advanced search statements

It is possible to modify attributes of the entire enclosing class with search
statements. Take the following rule which matches any c-preprocessor token.

class cppTokenMatch {
    
    definitionBase token;
    cppTokenMatch := cIdentifier : reverseTreeScope(
        definitionBase.name == cIdentifier : token = definitionBase , halt);
}

definitionBase is an abstract type, so can be used to point to any of the
subclasses (class composition is always performed using references in memory
and the database).

In this case there are two statements after the query, the first assigns the
locates AST node to the attribute. A "," is used to seperate statements, the
next halt statement in the reverse tree scope simply indicates to stop
the search when it is reached (return automatically halts the search).

NOTE: abstract class references can be implemented with virtual functions and
pointers or multi-indexing methods, both have their drawbacks and advantages 
but are slower than general reference indexes so the imposition of this should 
be considered when using references to abstract classes.

* Improving the include object to store the macro reference

When including the result of a preprocessor token it would be useful to store a
handle to c-preprocessor definition that the include statement received the
file value from. This can be done through the attribute includeToken as shown
below.

class include : statement {
    string includeFile;
    varDefinition includeToken;  # reference to rule which built this
    bool   isSystemHeader = false;

    sysHeaderInclude := includeFile( cppSysInclude{ sSystemHeader = true; gccSysParse() } );
    generalInclude   := includeFile( cppString { gccParse() } );
    
    # : begins the search statement
    evalStm := cIdentifier : reverseTreeScope( 
        varUndefinition.name == cIdentifier : error("including undefined identifier $cIdentifier");
        varDefinition.name == cIdentifier   : includeToken = varDefinition, return(varDefinition.value);
        noMatch                             : error("#include of non-existent preprocessor token $cIdentifer"));

    treeSearchInclude := generalInclude(evalStm) | sysHeaderInclude(evalStm);

    include := 'include' (  sysHeaderInclude  | generalInclude |
                            treeSearchInclude );
}

In this case the matching varDefinition is assigned to the includeToken 
reference attribute is we find a matching macro.

* Rule parameters and extending tree searches

It would be nice to factor out the evalStm functionality into a base class as
it is useful generic functionality. In its current form it is not suitable
for this purpose as the error messages are specific. By factoring out these
elements into parameters the rule can be used in subclasses. 

class macroStore {
    varDefinition macro;  # reference to token rule

    evalStm := cIdentifier : reverseTreeScope( 
            varDefinition.name == cIdentifier : macro = varDefinition , return(varDefinition.value));

    # overload and append err messages, +reverseTreeScope is used to append 
    # additional rules to the matcher
    evalStm(undefMsg, notfoundMsg) := evalStm : +reverseTreeScope( 
        varUndefinition.name == cIdentifier : error(undefMsg);
        noMatch                             : error(notfoundMsg));
}

In this implementation of macroStore there is an overloaded version of the
rule evalStm which takes arguments. It uses these arguments to ammend the tree
search by using +reverseTreeScope which adds search predicates to an existing
search of the same type.

* Multiple inheritance

class include : statement, macroStore {
    string includeFile;
    bool   isSystemHeader = false;

    sysHeaderInclude := includeFile( cppSysInclude{ sSystemHeader = true; gccSysParse() } );
    generalInclude   := includeFile( cppString { gccParse() } );

    evalStm := evalStm(undefMsg = "including undefined identifier $cIdentifier",
                       notfoundMsg = "#include of non-existent preprocessor token $cIdentifer");
    
    treeSearchInclude := generalInclude(evalStm) | sysHeaderInclude(evalStm);

    include := 'include' (  sysHeaderInclude  | generalInclude |
                            treeSearchInclude );
}

Now evalStm inherits from both statement and macroStore (in the generated code
multiple inheritance is used for this purpose). evalStm overloads the
macroStore parent version by calling it with the relevant error message
strings. notfoundMsg relies on matching the parent rule's $cIdentifier token,
but maryam can detect this through the constructor call. evalStm can be called
using two different syntaxes:

`evalStm(arg1, arg2)', or `evalStm(undefMsg = arg1, notfoundMsg = arg2)'.

* Inline classes and scope issues

It would be useful if #ifdef statements that evaluated falsely would keep
tokens withen the statement from affecting the scope of rules found after the
ifdef statement concludes.

For example

#ifdef 0
#define MUNCH
#endif

#ifdef MUNCH
#define THIS_SHOULD_NOT_AFFECT_THE_SCOPE
#endif

Then a simple understanding of the c-preprocessor shows that
THIS_SHOULD_NOT_AFFECT the scope should follow it's name. To ensure this
happens #ifdef statements can raise the scope when they do not evaluate to
ensure they are not found in tree searches, and flatten to the enclosing tree
otherwise. For this purpose an inline class can be used. An inline class does
not create a new node in the tree by default, as most classes do, but using
the direct "raiseScope", it can acheive this purpose artificially when the
symbol is undefined. 

inline class ifdefStm : statement, macroStore {
    bool undefined = false;

    evalStm ifdefResult := evalStm : +reverseTreeScope( 
        noMatch                             : undefined = true;
        varUndefinition.name == cIdentifier : undefined = true; halt;

    ifdefStm := ^ "ifdef" ifdefResult{ if (undefined, raiseScope()) };
}

ifdefStm overrides evalStm to modify a status variable if the definition is
not found.

This makes sure the scope is raised when the symbol is not defined. The first
argument to `raiseScope' is a reference to a class to push onto the scope. By
default it passes `this', a reference to the class itself.

* Extending tokenstore to support functional macros

It is possible in the c-preprocessor to generate certain code from macros and
the arguments which are passed. It should be possible to write a generic way
from the resulting expansion of any macro, with arguments or just a simple
definition. This can be done by providing a rule with arguments which will
store the result of evaluating the macro or definition.

The previous definition of a functional macro was using the simplified
macroBody rule, which is corrected in the following implementation:

class functionDefinition : definitionBase {
	parameterList parameters;

    # any token as supplied by the tokeniser
    vector<token> macroTokens;

    macroBody := macroTokens;

    # TODO: Fill me in
    functionDefinition := parameters macroBody;
}

* About parser tokens
The parser token symbol is automatically constructed from a list of all
string and character literals in the code, along with all the types used in
reachable rule matches. The built-in type token will match any single token as
supplied by the tokeniser.

Suggested Music: Mogwai - Ten Rapid
