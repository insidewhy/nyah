////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Program maintains "parse before" list..
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

i.e. #include <stdio.h>

Means stdio.h must be parsed before the rest of the body

e.g.

include := "#include"[ atColumn(0) ] '<' string[ exclude('>') ] < parseFileBefore() > '>';

// use ^ for begining!
include := ^"#include" '<' string[ exclude('>') ]<parseFileBefore> '>'

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Setting the scope:
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

nameSpaceDeclaration := 'namespace' string < pushScope('namespace') > '{';

// the () are required to disambiguate a function call that is not attached to
// an object from a normal identifier.
nameSpaceDeclarationEnd := '}' popScope();

program := programItem+;

programItem := nameSpaceWithContents | etc.

// nameSpaceEnd is required to pop the scope but this could be inlined but
// would look confusing
nameSpaceWithContents := nameSpaceDeclaration nameSpaceContents nameSpaceDeclarationEnd;

// the varName object automatically gets passed to the pushScope function which
// takes the string element from it to determine what to push into the scope.
// the first argument supplied by the user which this function requires is the
// Therefore it pushes classDeclaration 
// It must also add the element to the current scope as well, hence 
// "addToAndPush" instead of just "push" (addTo is first because it is 
// alphabetically ordered
classDeclaration := { ( 'class' | 'struct' ) } 
                    varName < addToAndPushScope('classDeclaration') > 
                    '{';

classEnd :=         '}' popScope(); 

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Testing the scope:
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

e.g.

In c++

funcCall(); 

could be a call to a method/function or an operator() invocation on a functor in the case of

Functor funcCall;
funCall();

classInsantiation := string< findInScope(('classDeclaration'|'structDeclaration') ) > 
                     identifier< addToScope('classVariable') > ';' ;

varInstantiation := classInstantation | etc.

// the special variable $1 appended with the string "operator::()". However $1 
// is substituted with the result of the first { } capture as for perl's brackets
// see later for an explanation of how argumentList returns a comma delimmited
// string of the type names instead of the text it matches when it is accessed
// via $2
bracketsOperatorCall := { identifier< findInScope('classVariable') > } { argumentList } ';' 
                        addToTable('methodCall', $1 + 'operator::()(' + $2 + ')');

functionCall := string '(' argumentList ')' ';' ;

// bracketsOperatorCall is first so it is ordered before functionCall in the test list
expression := bracketsOperatorCall |
              functionCall | 
              varInstantiation (etc.)

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Rules that return values other than the string they matched
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// argument list contains a string which is a comma seperated list of the types
// passed in. Here prune() is used to prune data out of the return type so only the
// argument types are returned
argumentList := 
    whiteSpace |
        identifier< findInScope('classDeclaration') > identifier[ prune() ]
        ( ',' identifier< findInScope('classVariable') > identifier[ prune() ] )* ;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// object based idea
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


< object > :=
    
object method {
}

object class {
    int numberOfTemplateParameters = 0;
    string className;
    vector<string> templateNames;
    vector<method> methods;
    
    templateDeclarationList :=
        'template' '<' ('typename'|'class') 
        identifier< ++numberOfTemplateParameters ; pushBack(templateNames) > '>'
        
    
    BEGIN:
        templateDeclarationList? ('class'|'struct') identifier< set(className) >

    CONTENTS:
        method< pushBack(method); > |
        
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// include c++ definitions directly
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


// ..

// 
static void someFunctionTakingStringFromRule(char * const inStr);
static void storeClassNameInDatabase(Database& iCodeBase, const * const inStr);
static void someFunctionTakingCurrentScope

// then the ebnf file

#include <HeaderFile.hpp>

// automatically works out to pass in what was matched by string
functionCall := bracketsOperatorCall

// automatically works out to pass in what was matched by string and the
// current database context
class := 'class' string< storeClassNameInDatabase >


