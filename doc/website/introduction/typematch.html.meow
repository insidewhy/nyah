!html
head {
    %title nyah - introduction - type matching
    link(rel=stylesheet, type=text/css, href=../css/global.css)
}

!body

%h2 Type matching

%p Type match control structures are useful for testing an object against a set of types and acting differently depending on the type. Type matches match the most specific match rather than testing the matches in order and resolve the lookup at compile time into a single fast call. In type matches &ldquo;?&rdquo; can match any type.

%code(langdef=/usr/share/source-highlight/nyah.lang) <<EOF
def funprint(a) {
    std.print("{ ")
    ~(a) {
        // ? matches anything but void
        ?          ->  println("something: " + a)
        // void is matched when a is not supplied
        void       ->  println("nothing")
        // ... matches 0 to many types, -> is optional before {
        vector[...]  {
            std.print("vector ")
            for(v ; a.tail()) std.print(v)
            println()
        }
        // each ? could be a different type
        // The code to build $"..." strings is created at compile time and is
        // equivalent to using a string builder to create the string with $a.first
        // and $a.second coming from the surrounding scope.
        pair[?, ?] ->  println($"pair ${a.first}, ${a.second}")
    }
    std.print(" }")
}

funprint()
funprint(14)
funprint(vector[string] [ "joined", "fun", "kittens" ])

// Variables from surrounding scope can be used in expressions.
def prefix_print(prefix:string, a) ~(a) {
    string -> println(prefix .. a)
    ?      -> {}
}

prefix_print("friend-", "hello")
prefix_print("friend-", 4)

// def~ can be used to create a function that matches on all of its arguments.
def~ merge_to_string(a, b) {
    ?A, A  -> $"same: $a $b"
    ...    -> $"mixed: $a $b"
}

// Match objects can handle multiple arities and return data.
// => is a shorthand for "-> ="
def~ string_desc(...a) {
    ?      => "1"
    ?A, A  => "2 same"
    ?, ?   => "2 different"
    ...    => ">2 different"
    ..:?A  => ">2 same"  // ..:RHS is like ... but all the types are RHS
}

prinln(string_desc(1, false)) // print "2 different"
prinln(string_desc(1, 1, 1, 1)) // print ">2 same"
// prinln(string_desc()) // no matches.. compiler error

// You can specify the return types of matches if you want:
def~ simple_desc(...a):string {
    ?    => "single"
    ?, ? => 1  // error: type does not match return type.
}

// Match objects can work as meta-functions that accept types rather than
// actual variables using the ~[...] form. In this case the type is always
// returned at compile time in place of the match.
meta if[C, T, F] : ~[C] { true => T ; ? => F }

EOF

%a(href=metafunc.html) previous | " | " | %a(href=index.html) up | " | " | %a(href=operators.html) next
