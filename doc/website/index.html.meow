!html
head {
    %title nyah
    link(rel=stylesheet, type=text/css, href=css/global.css)
}

!body

%h1 Nyah

#links {
    links:
    %a(href=http://github.com/tuxjay/nyah) source
    %a(href=cplusplus.html) nyah vs c++(0x)
}

%p { Nyah is a systems programming language designed to allow code to be written that performs as well as or better than traditional systems languages like C and C++. Nyah is typed, but uses type inference so types can usually be ommitted. Nyah has strong meta-programming capabilities. It uses the | %a(href=http://llvm.org) LLVM | compiler infrastructure to generate object code and | %a(href=http://vmkit.llvm.org/) VMKit | to generate bytecode if garbage collection is turned on. }

%h2 Aims
%p Nyah looks to many other languages for inspiration, especially C++0x, scala and D.

%ul {
    %li Improve the powerful meta-programming functionalities of C++0x and D whilst simplifying the syntax.
    %li Exceed the type inference and DSL building capabilities of scala.
    %li Provide a fast and free MIT licensed compiler implementation.
    %li Provide a powerful and intelligent compiler which will infer information to save developers from repetitive typing when safe to do so.
    %li Optional garbage collection. Nyah should target both vmkit and LLVM to allow it to be used both with and without a garbage collector.
    %li Object orientated (including multiple inheritance), meta, functional and declarative programming styles are supported.
}

%h2 Syntax can be extended/modified at compile time.

%p New features can be added to the language and the compiler from within nyah code itself. This not only allows many powerful features to be expressed neatly in the language, but makes nyah an ideal "compiler toolkit". It is conceivable to import the syntax of a pre-existing language into nyah, for example, the nyah grammar module allows PEG based parsers to be expressed directly in a PEG based notation within the language. This variant of PEGs allows AST building capabilities to be expressed with the parsing grammar. This allows powerful modifications and extensions to be expressed neatly and simply. The nyah parser itself is implemented with this module.

%h2 Fast, powerful, non-verbose meta-programming

%p Whilst the goals are ambitious the nyah compiler achieves them neatly by approaching compilation in a unique way. The compiler outputs assembly code during the compilation process to allow it to run meta-programs quickly. Whilst this approach adds another layer of indirection which would make the compilation of traditional code slightly slower, it allows code that takes advantage of meta-programming to be compiled very quickly. It also allows type inference to be more powerful than a language like scala. In nyah even functions that recursively call other meta-functions can benefit from return type inference.

%h2 Variables

%pre <<EOF
    // Initialisation and assignment.
    a : uint = 0

    // Type of b is inferred by compiler.
    b := 0

    // Construct object on stack.
    v_stack := vector[int]()

    // Construct object on heap.
    v_heap := new vector[int]()

    // Make a reference.
    v_heap_ref :& = v_heap
EOF

%h2 Semicolons

%p Semicolons are only needed where necessary to resolve ambiguity. In order for this to work, binary operators should not appear at the beginning of a new line.

%pre <<EOF
    // This is fine.
    a := 1 + 2 +
        3

    // This is two statements: (b := 1 + 2) and (+3)
    b := 1 + 2
        + 3
EOF

%h2 Control structures

%pre <<EOF
    // (= value) is equivalent to (return value) at function scope.
    def bread() { = "bread" }
    def uncle() { return "uncle" }

    // if/else can return values.
    a := false
    b := if (a) =1; else =2
    c := a ? 1 : 2

    // while can return a value if it has a return statement. In which
    // case the result of the value on the last iteration will be used.
    // This can also be used for foreach and for loops. "return" should
    // be used in order to return data from a function within a loop.
    str  := "pumpo"
    iter := str.begin
    first_m :=  while (*iter != "m") = ++iter

    // for loop.
    for (i := 0; i < 10; ++i) println(i)

    // Range based for loop.
    v := vector(1, 2, 3, 4)
    foreach (i ; v) println(i)

    // Use two values at a time in loop.
    foreach (i1, i2 ; v) println(i1, ", ", i2)
EOF

%h2 Functions

%pre <<EOF
    // A function with a single statement.
    def add(a:const int, b:const int):int
        return a + b

    // Return type can always be omitted, in which case it is inferred
    // by the compiler.
    def subtract(a:const int, b:const int) = a - b

    // A function containing several statements.
    def divide(a:const int, b:const int) {
        assert(b != 0)
        return a / b
    }

    // Argument types may also be omitted.
    def generic_add(a, b) = a + b

    // A new function is generated for each set of argument types,
    // so the following two calls created two different functions.
    generic_add(1, 2)
    generic_add(1f, 2f)

    // assign_ptr's first argument can be any type, but must be a
    // pointer. The second argument may be passed from a const or non-const
    // expression (unless a more specific non-const overload exists) but
    // is treated as a const variable within the function.
    def assign_ptr(a:*, b:const) *a = b

    // Functions can be overloaded, the most specific function always
    // matches.
    def end(a) = a.end()

    def end(a:char *) {
        while (*a != '\0') ++a
        return a
    }

    def end(a:*) {
        // create a compile time error if called.
        @error "Cannot retrieve end of pointer"
    }

    // A function containing return types with different statements can
    // be made to return a "variant[T...]" where T... is the set of types
    // of all possible return types. T... is deduced by the compiler.
    // variant is implemented as a set of types and meta-programs within
    // nyah itself with no special compiler support necessary.
    def item_or_false(v, i):variant {
        it := v.find(i)
        return it == v.end ? false : it
    }

EOF

%h2 Arrays

%pre <<EOF
    // create array of 3 integers
    a := [[ 1, 2, 3 ]]

    // Create array of 3 integers and assign elements in a run-time loop.
    c := [[ i : 0..3, i ]]

    // As above but create values at compile time.
    b := [[ i ?: 0..3, i ]]

    // Index second element of array. [ and ] are used for type
    // parameters, so ( and ) are used for arrays in nyah as in scala.
    print(b(1))
EOF

%h2 Status

%h3 Parser generator
%ul {
    %li { .completed COMPLETED | Research new notation to extend PEG to include &ldquo;AST-building&rdquo; parsers. Read paper | a(href=http://chilon.net/papers/tbpeg.pdf) TBPEGs }
    %li { .completed COMPLETED | chilon::parser, a C++0x implementation of TBPEGs, to be used in the bootstrap compiler. Project website | a(href=http://chilon.net/library.html) chilon::parser }
    %li { .completed COMPLETED | TBPEG parser in chilon::parser to be used for Nyah's grammar DSL. }
    %li { .inprogress IN PROGRESS | Code generator for TBPEG parser to output chilon::parser parsers. }
}

%h3 First compiler (written in C++0x) to be used for bootstrapping
%ul {
    %li { .inprogress IN PROGRESS | mousebear: full nyah language parser using parser generator. }
    %li { .yettostart YET TO START | Code generator using LLVM. }
}

%h3 Nyah standard library
%ul {
    %li { .inprogress IN PROGRESS | std::variant and std::tuple. }
    %li { .inprogress IN PROGRESS | containers: vector, vector_hash_map, hash_map, hash_set, set, map. }
    %li { .inprogress IN PROGRESS | nyah meta-programming library. }
    %li { .yettostart YET TO START | std::config argument parser. }
}

%h3 Second compiler (written in nyah)
%ul {
    %li { .yettostart YET TO START | nyah::parser based on chilon::parser. }
    %li { .yettostart YET TO START | TBPEG nyah syntax which will internally be based on nyah::parser. }
    %li { .yettostart YET TO START | Use nyah syntax from bootstrap compiler to produce full parser. }
    %li { .yettostart YET TO START | LLVM library for nyah based on LLVM C bindings. }
    %li { .yettostart YET TO START | Code generator using llvm library. }
    %li { .yettostart YET TO START | vmkit library for nyah. }
    %li { .yettostart YET TO START | Code generator for garbage collected nyah using vmkit library. }
}

%h2 Help wanted

%p Help is appreciated from anyone with research, implementation or art.
%div E-mail: nyah (@) chilon.net.
%div { IRC Channel: #nyah on | %a(href=irc://irc.freenode.net) "irc.freenode.net" }
