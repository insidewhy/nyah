Character Matches
    The following are constant:
        \n      Newline.
        \r      Linebreak.
        \s      Whitespace.
        \t      Tab.
        \'      Parser for single quote.
        \"      Parser to match double quote.
        [pqr]   Any of the individual characters p, q or r. Constant.
        'c'     Same as [c]
        "c"     Same as [c]
    The following are non-constant:
        \w      Word character (alphanumeric or _).
        \W      Non-word character (alphanumeric or _).
        \S      Non-whitespace.
        \d      Digit.
        \D      Non-digit.
        .       Any character.
        [p-z]    Match characters between p and z inclusive.
        [!pqr]   Match any character except p, q or r.
        [ps-z!r] Shortcut for ( [p] | [s-z] | [!r] ).

Multiple Character Matches
    The following are constant:
        "str"    Match the string str.
        'str'    Match the string str.
    The following are non-constant:
        Integer  Match any integer and stores an integer.
        Float    Match any float and stores a float.

Functions
    skip p  Match p and store nothing.

    store p Match p and always store it, even if p is constant.

    local var:p  Create a local variable named var with parser type p.
                 This exists during the parsing of the current rule only.

    match var    Return a parser that matches the character/string currently
                 stored in the variable var. The result of this counts as a
                 constant match, so will allow ! to skip it.

    var Name     Equivalent to name:Name

    type_join (t1 t2 ...)
        Collapse all non-constant character/string stores together to store
        a single string (including separating whitespace if it is allowed).
        Removes all remaining types that are constant.
        Store each collapsed item as an element in a tuple:
        e.g.
            type_join(\d+ \w+)
                would store "2 babies" as "2 babies" rather than
                tuple("2", "babies")
            type_join(\d+ \w+ name:StringNode \w+)
                => type_join(string name:StringNode string)
                => tuple(string, string)


Operator Precedence
    &p      Match p but leave the parser position where it was before the &p
            rule was matched even if p succeeds. Cannot store.

    !p      Returns false if p matches, and true if p fails.
            If !p succeeds and p is a constant match or character match then
            advance the parser over p (unless & is used before !), otherwise
            the position is left as it was before !p was matched.

    p*      Match p zero or more times.
            If p is a character match, don't allow whitespace in between each
            character and store a string, otherwise store list(p).
    p+      As above but p must match at least once.
    p?      Match p zero or once. Stores optional(p).
            These three operations are non-constant.

    n : p   Match p and store it in an attribute in the current class named n.
            Acts as though it stores nothing to the rule calling it.

    p - q   Equivalent to anything that matches p but not q. Stores p.

    p % q   Match p joined by q. Stores list(p). non-constant.

    p as q  Match p but store to it using the parser type q. The type of p 
            must be compatible with the type of p.

    p ^ q   Match p followed by q with no whitespace between.
            Stores type_join(p q).

    p  q    Match p followed by q.
            If p and q are both character match then do not allow whitespace
            to separate them and store type_join(p q).
            Otherwise allow optional whitespace to separate them and
            store tuple(p, q).

    p { d } If p is matched perform action d.

    function  See Functions

    p | q   Try to match p, then try to match q if that fails.
            Stores variant(store p, store q). Non-constant.

    p || q  Match p or q in sequence.

    p ~ q   Match p followed by q separated by optional whitespace.
            Non-constant. Stores tuple(p, q).

    p > q   If p matches and q does not, raise a global error.

Combinations
    p*? q
        Keep matching p until q matches. Stores tuple(p, q).

Type storage
    nothing         Is a const type.
    tuple(...)      Removes const types from the tuple.
    tuple(q) -> q   Single element tuple is not a tuple.
        s = "p" [a-z]
        type(s) = tuple(nothing, character)
                => tuple(character)
                => character

    optional(const type) => true if optional was matched, else false.

    variant(..., variant(...), ...) -> variant(..., ..., ...)
        s = 'a' | (Integer | Float)
        type(s) = variant(character, variant(int, float))
        type(s) = variant(character, int, float)

    variant()       Types which are the same are removed from the variant.
    variant(q) -> q
        s = 'a' | 'b'
        type(s) = variant(character, character)
        type(s) = variant(character)
        type(s) = character

    variant(..., character, ..., string, ...) -> variant(string)
        s = 'blimey' | Integer | 'a' | 'b'
        type(s) = variant(string, int, character, character)
        type(s) = variant(string, int, character)
        type(s) = variant(string, int)

Actions
    fail(message:string)    Raise global failure with indicated message.
