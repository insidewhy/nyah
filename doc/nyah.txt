Character Matches
    The following are constant:
        \n      Newline.
        \r      Linebreak.
        \s      Whitespace.
        \t      Tab.
        \'      Parser for single quote.
        \"      Parser to match double quote.
        'c'     Matches the character c.
        "c"     Same as 'c'.
    The following are non-constant:
        \w      Word character (alphanumeric or _).
        \W      Non-word character (alphanumeric or _).
        \S      Non-whitespace.
        \d      Digit.
        \D      Non-digit.
        .       Any character.
        [pqr]   Any of the individual characters p, q or r.
        [p-z]    Match characters between p and z inclusive.
        [!pqr]   Match any character except p, q or r.
        [ps-z!r] Shortcut for ( [p] | [s-z] | [!r] ).

Multiple Character Matches
    The following are constant:
        "str"    Match the string str.
        'str'    Match the string str.
    The following are non-constant:
        Integer  Match any integer and stores an integer.
        Float    Match any float and stores a float.
        Number   Same as (Integer | Float).

Operator Precedence
    &p      Match p but leave the parser position where it was before the &p
            rule was matched even if p succeeds. Does not store.

    !p      Fails if p matches, and succeeds if p fails.
            If !p succeeds, p is a character match, and it is not prefix by &
            then advance the parser one character, otherwise the position
            is left as it was before !p was matched. !p only stores if p is a
            non-constant character match.

    p*      Match p zero or more times.
            If p is a character match, don't allow whitespace in between each
            character and store a string, otherwise store list(p).
    p+      As above but p must match at least once.
    p?      Match p zero or once. Stores optional(p).
    p*? q   Same as p* but limit until q matches. Stores tuple(type of p*, q)
    p+? q   Same as p+ but limit until q matches. Stores tuple(type of p+, q)
            These five operations are non-constant.

    p -> r  Match p through calling the alternate begin rule r.

    n : p   Match p and store it in an attribute named n.
            If p is constant, then n will store a boolean which will only
            be true in objects where n was matched.

    p - q   Shortcut for (&!p q)

    p % q   Match p joined by whitespace and q.  Stores list(p). non-constant.

    p as q  Match p but store to it using the parser type q. The type of p
            must be compatible with the type of q.

    > q     If q does not match raise a global error.

    >> q    If q does not match, or if the current object is not matched
            after q, raise a global error.

    p ^ q   Match p followed by q with no whitespace between.
            Stores type_join(p q).

    p { d } If p is matched perform action d.

    p q     Match p followed by q.
            If p and q are both character matches then it is equivalent to
            (p ^ q).
            If q would also match the Whitespace rule then it is equivalent to
            (p ^ skip (Whitespace - q) ^ q).
            Otherwise allow optional whitespace to separate them and
            store tuple(p, q).

    function  See Functions

    p | q   Try to match p, then try to match q if that fails.
            Stores variant(p, q). Non-constant.

    p || q  Matches the same as (p | p q)  but stores
            tuple(optional(p), optional(q)).

    p ~ q   Match p followed by q separated by optional whitespace.
            Non-constant. Stores tuple(p, q).

Constant Matches Have Names.
    Constant matches have names identical to the string/character constant
    specified. Special characters are mapped according to the following table:
        \n      <newline>
        \r      <linebreak>
        \s      <whitespace>
        \t      <tab>
        \'      <quote>
        \"      <double quote>

    In the result that the constant match resulted from a type_join operations
    the names on the LHS are RHS are appended with a space:
        "hey"          -> hey
        "hey" ^ \t     -> hey <tab>
        "hey" ^ \r\n   -> hey <linefeed> <newline>

    Identifier names are the same as the name with spaces replace by
    underscores and all brackets removed:
        "hey" ^ \r\n   -> hey_linefeed_newline

Type storage
    Removes const types from a tuple.
        tuple(const t, ...) -> tuple(...)
        s = '$' String '=' Integer
        type(s) = tuple(const character, string, const character, int)
        type(s) = tuple(string, int)

    Single element tuples are not tuples.
        tuple(q) -> q
        s = "p" [a-z]
        type(s) = tuple(const character, character)
                => tuple(character)
                => character

    Nested variants are expanded into the current variant:
        variant(..., variant(...), ...) -> variant(..., ..., ...)
        s = 'a' | (Integer | Float)
        type(s) = variant(character, variant(int, float))
        type(s) = variant(character, int, float)

    Types that are the same are removed from the variant.
        variant(t, ..., t) -> variant(t, ...)
        s = \w | [_-] | Integer
        type(s) = variant(character, character, int)
        type(s) = variant(character, int)

    A character and string are collapsed to be a string.
    variant(..., character, ..., string, ...) -> variant(string, ...)
        s = \w+ | Integer | \d | \w
        type(s) = variant(string, int, character, character)
        type(s) = variant(string, int, character)
        type(s) = variant(string, int)

    variant(t) -> t

Actions
    fail(message:string)  Raise global failure with indicated message:
                          '"' (. | '$' { fail("$ not allowed in string") })* '"'

Functions that can also be used to prefix attributes.
    skip p   Match and store nothing.

    enum p   The type of p becomes "enum". All non-const matches in p are
             not stored, and constant matches write to an entry in the enum
             with the identifier name of the match prefix by enum_.
                p = enum ('a'\n | 'b') Number
                type(p) = enum { enum_a_newline, enum_b }

Functions that can only be used to prefix attributes.
    local p  p acts like an attribute but is a variable stored only during
             the parsing of the current object.

    key p    The attribute p will become part of the key of the current class.
             Two objects of the same type with the same key may not exist in
             the same scope.

Functions that cannot be used to prefix attributes
    local var:p  Create a local variable named var with parser type p.
                 This exists only during the parsing of the current object.

    match p      Return a parser that matches the character/string currently
                 stored in the attribute p. The result of this counts as a
                 constant match.

    store p      Do not remove the match of p from tuples even if it constant.

    var Name     Equivalent to name:Name // CONSIDERING

    key var:p    Create an attribute var of type p. The pattern this attribute
                 matches will become part of the key of this object.

    epsilon      Always matches and skips nothing.

    type_join (t1 t2 ...)
        1. Collapse all adjacent non-constant character/string stores together
           to store a single string (including separating whitespace if it is
           allowed).
        2. Remove all remaining types that are constant.
        3. Store each remaining item as an element in a tuple:
        e.g.
            type_join(\d+ \w+)
                would store "2 babies" as "2 babies" rather than
                tuple("2", "babies")
            type_join(\d+ \w+ name:StringNode \w+)
                => type_join(string string name:StringNode string)
                => type_join(string name:StringNode string)
                => tuple(string, string)
        type_join is constant only if (t1 t2 ...) are constant.

    TODO
        Mark unimplemented rule, raises an error when parsing

Special declarations
    grammar <quoted or double quoted string>
        Start a grammar from here until the next grammar statement or the end
        of the file.

Special classes
    Whitespace.
        By default:
            skip Whitespace = \s*
        This rule is used to skip whitespace between rules when and as
        described above in addition to the comment rule. Use skip if
        whitespace should not be stored in the tree.

    Comment.
        By default:
            skip Comment = '//' .*? \n | '/*' .*? '*/'
        Used for skipping whitespace as described above. Use skip if
        comments should not be stored in the tree. This should be a good
        place to include a documenting system.

    Global
        The entry rule to the grammar.
