Character Matches
    The following are constant:
        \n      Newline.
        \r      Linebreak.
        \s      Whitespace.
        \t      Tab.
        \'      Parser for single quote.
        \"      Parser to match double quote.
        'c'     Matches the character c.
        "c"     Same as 'c'.
    The following are non-constant:
        \w      Word character (alphanumeric or _).
        \W      Non-word character (alphanumeric or _).
        \S      Non-whitespace.
        \d      Digit.
        \D      Non-digit.
        .       Any character.
        [pqr]   Any of the individual characters p, q or r.
        [p-z]    Match characters between p and z inclusive.
        [!pqr]   Match any character except p, q or r.
        [ps-z!r] Shortcut for ( [p] | [s-z] | [!r] ).

Multiple Character Matches
    The following are constant:
        "str"    Match the string str.
        'str'    Match the string str.
    The following are non-constant:
        Integer  Match any integer and stores an integer.
        Float    Match any float and stores a float.
        Number   Same as (Integer | Float).

Functions that can also be used to prefix attributes.
    skip p       Match and store nothing.

Functions that can only be used to prefix attributes.
    local p      p acts like an attribute but is a variable stored only during
                 the parsing of the current object.

Functions that cannot be used to prefix attributes
    local var:p  Create a local variable named var with parser type p.
                 This exists only during the parsing of the current object.

    match p      Return a parser that matches the character/string currently
                 stored in the attribute p. The result of this counts as a
                 constant match.

    store p      Do not remove the match of p from tuples even if it constant.

    var Name     Equivalent to name:Name

    key var:p    Create an attribute var of type p. The pattern this attribute
                 matches will become part of the key of this object. In the
                 same scope two objects of the same type with the same key may
                 not exist.

    epsilon      Always matches and skips nothing.

    type_join (t1 t2 ...)
        1. Collapse all adjacent non-constant character/string stores together 
           to store a single string (including separating whitespace if it is 
           allowed).
        2. Remove all remaining types that are constant.
        3. Store each remaining item as an element in a tuple:
        e.g.
            type_join(\d+ \w+)
                would store "2 babies" as "2 babies" rather than
                tuple("2", "babies")
            type_join(\d+ \w+ name:StringNode \w+)
                => type_join(string string name:StringNode string)
                => type_join(string name:StringNode string)
                => tuple(string, string)

    TODO
        Mark unimplemented rule, raises an error when parsing


Operator Precedence
    &p      Match p but leave the parser position where it was before the &p
            rule was matched even if p succeeds. Does not store.

    !p      Fails if p matches, and succeeds if p fails.
            If !p succeeds and p is a constant match or character match then
            advance the parser over p (unless & is used before !), otherwise
            the position is left as it was before !p was matched. !p only
            stores if p is a non-constant character match.

    p*      Match p zero or more times.
            If p is a character match, don't allow whitespace in between each
            character and store a string, otherwise store list(p).
    p+      As above but p must match at least once.
    p?      Match p zero or once. Stores optional(p).
    p*? q   Same as p* but limit until q matches. Stores tuple(type of p*, q)
    p+? q   Same as p+ but limit until q matches. Stores tuple(type of p+, q)
            These five operations are non-constant.

    p -> r  Match p through calling the alternate begin rule r.

    n : p   Match p and store it in an attribute named n.
            If p is constant, then n will store a boolean which will only 
            be true in objects where n was matched.

    p - q   Shortcut for (&!p q)

    p % q   Match p joined by whitespace and q.  Stores list(p). non-constant.

    p as q  Match p but store to it using the parser type q. The type of p 
            must be compatible with the type of q.

    > q     If q does not match raise a global error.

    >> q    If q does not match, or if the current object is not matched
            after q, raise a global error.

    p ^ q   Match p followed by q with no whitespace between.
            Stores type_join(p q).

    p { d } If p is matched perform action d.

    p q     Match p followed by q.
            If p and q are both character matches then it is equivalent to 
            (p ^ q).
            If q would also match the Whitespace rule then it is equivalent to
            (p ^ skip (Whitespace - q) ^ q).
            Otherwise allow optional whitespace to separate them and
            store tuple(p, q).

    function  See Functions

    p | q   Try to match p, then try to match q if that fails.
            Stores variant(p, q). Non-constant.

    p || q  Matches the same as (p | p q)  but stores 
            tuple(optional(p), optional(q)).

    p ~ q   Match p followed by q separated by optional whitespace.
            Non-constant. Stores tuple(p, q).

Type storage
    Removes const types from a tuple.
        tuple(const t, ...) -> tuple(...)
        s = '$' String '=' Integer
        type(s) = tuple(const character, string, const character, int)
        type(s) = tuple(string, int)

    Single element tuples are not tuples.
        tuple(q) -> q   
        s = "p" [a-z]
        type(s) = tuple(const character, character)
                => tuple(character)
                => character

    Nested variants are expanded into the current variant:
        variant(..., variant(...), ...) -> variant(..., ..., ...)
        s = 'a' | (Integer | Float)
        type(s) = variant(character, variant(int, float))
        type(s) = variant(character, int, float)

    Types that are the same are removed from the variant.
        variant(t, ..., t) -> variant(t, ...)
        s = \w | [_-] | Integer
        type(s) = variant(character, character, int)
        type(s) = variant(character, int)

    A character and string are collapsed to be a string.
    variant(..., character, ..., string, ...) -> variant(string, ...)
        s = \w+ | Integer | \d | \w
        type(s) = variant(string, int, character, character)
        type(s) = variant(string, int, character)
        type(s) = variant(string, int)

    variant(t) -> t

Actions
    fail(message:string)  Raise global failure with indicated message:
                          '"' (. | '$' { fail("$ not allowed in string") })* '"'
