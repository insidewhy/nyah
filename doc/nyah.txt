Character Matches
    The following are constant:
        \n      Newline.
        \r      Linebreak.
        \s      Whitespace.
        \t      Tab.
        \'      Parser for single quote.
        \"      Parser to match double quote.
        'c'     Matches the character c.
        "c"     Same as 'c'.
    The following are non-constant:
        \w      Word character (alphanumeric or _).
        \W      Non-word character (alphanumeric or _).
        \S      Non-whitespace.
        \d      Digit.
        \D      Non-digit.
        .       Any character.
        [pqr]   Any of the individual characters p, q or r.
        [p-z]    Match characters between p and z inclusive.
        [!pqr]   Match any character except p, q or r.
        [ps-z!r] Shortcut for ( [p] | [s-z] | [!r] ).

Multiple Character Matches
    The following are constant:
        "str"    Match the string str.
        'str'    Match the string str.
    The following are non-constant:
        Integer  Match any integer and stores an integer.
        Float    Match any float and stores a float.
        Number   Same as (Integer | Float).

Operator Precedence
    &p      Match p but leave the parser position where it was before the &p
            rule was matched even if p succeeds. Does not store.

    !p      Fails if p matches, and succeeds if p fails.
            If !p succeeds, p is a character match, and it is not prefix by &
            then advance the parser one character, otherwise the position
            is left as it was before !p was matched. !p only stores if p is a
            non-constant character match.

    p*      Match p zero or more times.
            If p is a character match, don't allow whitespace in between each
            character and store a string, otherwise store list(p).
    p+      As above but p must match at least once.
    p?      Match p zero or once. Stores optional(p).
    p*? q   Same as p* but limit until q matches. Stores tuple(type of p*, q)
    p+? q   Same as p+ but limit until q matches. Stores tuple(type of p+, q)
            These five operations are non-constant.

    p -> r  Match p through calling the alternate begin rule r.

    p named n
            Give the match p the name n. This n is useful for producing
            more accurate output. Each name has a corresponding "identifier
            name", which is obtained by replacing whitespace with underscores,
            and removing all non alphanumeric characters from the name. This
            identifier name is used in the enum function.

    n : p   Match p and store it in an attribute named n.
            If p is constant, then n will store a boolean which will only
            be true in objects where n was matched.

    p - q   Shortcut for (&!p q)

    p % q   Match p joined by whitespace and q.  Stores list(p). non-constant.

    p as q  Match p but store to it using the parser type q. The type of p
            must be compatible with the type of q.

    > q     If q does not match raise a global error.

    >> q    If q does not match, or if the current object is not matched
            after q, raise a global error.

    p ^ q   Match p followed by q with no whitespace between.
            Stores type_join(p q).

    p { d } If p is matched perform action d.

    p q     Match p followed by q.
            If p and q are both character matches then it is equivalent to
            (p ^ q).
            If q would also match the Whitespace rule then it is equivalent to
            (p ^ skip (Whitespace - q) ^ q).
            Otherwise allow optional whitespace to separate them and
            store tuple(p, q).

    modifier  See Modifiers

    p | q   Try to match p, then try to match q if that fails.
            Stores variant(p, q). Non-constant.

    p || q  Ordered sequence. Matches the same as (p | p q) but stores:
            tuple(optional(p), optional(q)).

    p ||| q Unordered sequence. Matches the same as (p q? | q p?) but stores:
            tuple(optional(p), optional(q)).

    p ~ q   Match p followed by q separated by optional whitespace.
            Non-constant. Stores tuple(p, q).

Constant Matches Have Default Names.
    Constant matches have names identical to the string/character constant
    specified. Special characters are mapped according to the following table:
        \n      <newline>
        \r      <linebreak>
        \s      <whitespace>
        \t      <tab>
        \'      <quote>
        \"      <double quote>

    In the result that the constant match resulted from a type_join operations
    the names on the LHS are RHS are appended with a space:
        "hey"          -> hey
        "hey" ^ \t     -> hey <tab>
        "hey" ^ \r\n   -> hey <linefeed> <newline>

    Identifier names are the same as the name with spaces replace by
    underscores and all brackets removed:
        "hey" ^ \r\n   -> hey_linefeed_newline

Tuple Details.
    Const types are always removed from tuples unless prefixed with the
    store modifier. A tuple with one type is replaced with that type.

Tuple Examples.
    s = '$' String '=' Integer
        type(s) =  tuple(const character, string, const character, int)
                => tuple(string, int)

    s = "p" [a-z]
        type(s) =  tuple(const character, character)
                => tuple(character)
                => character


Variant Details.
    A variant is a set of types. Any subvariant is removed from a variant
    and it's elements are combined with the parent variant's type set.
    Strings and characters are considered to be identical types to the variant
    but if both are present the string will replace the character. A variant
    with one type is replaced with that type.

Variant Examples.
    s = 'a' | (Integer | Float)
        type(s) = variant(character, variant(int, float))
        type(s) = variant(character, int, float)

    s = \w | [_-] | Integer
        type(s) = variant(character, character, int)
        type(s) = variant(character, int)

    s = \w+ | Integer | \d | \w
        type(s) = variant(string, int, character, character)
        type(s) = variant(string, int, character)
        type(s) = variant(string, int)

    variant(t) -> t

Actions
    fail(message:string)  Raise global failure with indicated message:
                          '"' (. | '$' { fail("$ not allowed in string") })* '"'

Modifiers that can also be used to prefix attributes.
    skip p   Match and store nothing.

    enum p
        It is easiest to understand this with some examples:
                p = enum ('first' | 'second')
                type(p) = enum { enum_first = 0, enum_second = 1 }
                "first"   -> 0
                "second"  -> 1

                enum p = 'a' || 'b' || 'c'
                type(p) = enum { enum_a = 1, enum_b = 2, enum_c = 4 }
                "a b" -> 3
                "b c" -> 6

        The type of p becomes an enumeration. All named matches in p are
        stored as an entry in the enum attribute with the identifier name
        of the match prefix by enum_. If it is
        determined that multiple enum entries can match, then the
        enum values are set in powers of 2 and additive. Constant matches
        are always named and stored as they have default names, and
        skip should be placed before non-named matches to silence
        compiler warnings.

Modifiers that can only be used to prefix attributes.
    local p  p acts like an attribute but is a variable stored only during
             the parsing of the current object.

    key p    The attribute p will become part of the key of the current class.
             Two objects of the same type with the same key may not exist in
             the same scope.

Modifiers that cannot be used to prefix attributes.
    local var:p  Create a local variable named var with parser type p.
                 This exists only during the parsing of the current object.

    match p      Return a parser that matches the character/string currently
                 stored in the attribute p. The result of this counts as a
                 constant match and is named after the matching string. It's
                 identifier name however will be match_p:
                     func = 'begin' name:String .*? ~
                            'end' enum (match name | 'default')
                     type(func) =
                        tuple(string, enum { enum_match_name, enum_default })

    store p      Do not remove the match of p from tuples even if it constant.

    var Name     Equivalent to name:Name // CONSIDERING

    key var:p    Create an attribute var of type p. The pattern this attribute
                 matches will become part of the key of this object.

    epsilon      Always matches and skips nothing.

    type_join (t1 t2 ...)
        1. Collapse all adjacent non-constant character/string stores together
           to store a single string (including separating whitespace if it is
           allowed).
        2. Remove all remaining types that are constant.
        3. Store each remaining item as an element in a tuple:
        e.g.
            type_join(\d+ \w+)
                would store "2  babies" as "2  babies" rather than
                tuple("2", "babies")
            type_join(\d+ \w+ name:StringNode \w+)
                => type_join(string string name:StringNode string)
                => type_join(string name:StringNode string)
                => tuple(string, string)
        type_join is constant only if (t1 t2 ...) are constant.

    TODO
        Mark unimplemented rule, raises an error when parsing

Special declarations
    grammar <quoted or double quoted string>
        Start a grammar from here until the next grammar statement or the end
        of the file.

Special classes
    Whitespace.
        By default:
            skip Whitespace = \s*
        This rule is used to skip whitespace between rules when and as
        described above in addition to the comment rule. Use skip if
        whitespace should not be stored in the tree.

    Comment.
        By default:
            skip Comment = '//' .*? \n | '/*' .*? '*/'
        Used for skipping whitespace as described above. Use skip if
        comments should not be stored in the tree. This should be a good
        place to include a documenting system. Another grammar can be
        imported to use for this.

    Global
        The entry rule to the grammar.
