Character Matches
    The following are constant:
        \n      Newline.
        \r      Linebreak.
        \s      Whitespace.
        \t      Tab.
        \'      Parser for single quote.
        \"      Parser to match double quote.
        [pqr]   Any of the individual characters p, q or r. Constant.
        'c'     Same as [c]
        "c"     Same as [c]
    The following are non-constant:
        \w      Word character (alphanumeric or _).
        \W      Non-word character (alphanumeric or _).
        \S      Non-whitespace.
        \d      Digit.
        \D      Non-digit.
        .       Any character.
        [p-z]    Match characters between p and z inclusive.
        [!pqr]   Match any character except p, q or r.
        [ps-z!r] Shortcut for ( [p] | [s-z] | [!r] ).

Multiple Character Matches
    The following are constant:
        "str"    Match the string str.
        'str'    Match the string str.
    The following are non-constant:
        Integer  Match any integer and stores an integer.
        Float    Match any float and stores a float.

Functions
    skip p  Match p and store nothing.

    store p Match p and always store it, even if p is constant.

    local var:p  Create a local variable named var with parser type p.
                 This exists during the parsing of the current rule only.

    match p      Return a parser that matches the character/string currently
                 stored in the attribute p. The result of this counts as a
                 constant match.

    var Name     Equivalent to name:Name

    epsilon      Always matches and skips nothing.

    type_join (t1 t2 ...)
        1. Collapse all adjacent non-constant character/string stores together 
           to store a single string (including separating whitespace if it is 
           allowed).
        2. Remove all remaining types that are constant.
        3. Store each remaining item as an element in a tuple:
        e.g.
            type_join(\d+ \w+)
                would store "2 babies" as "2 babies" rather than
                tuple("2", "babies")
            type_join(\d+ \w+ name:StringNode \w+)
                => type_join(string string name:StringNode string)
                => type_join(string name:StringNode string)
                => tuple(string, string)


Operator Precedence
    &p      Match p but leave the parser position where it was before the &p
            rule was matched even if p succeeds. Does not store.

    !p      Fails if p matches, and succeeds if p fails.
            If !p succeeds and p is a constant match or character match then
            advance the parser over p (unless & is used before !), otherwise
            the position is left as it was before !p was matched. !p only
            stores if p is a non-constant character match.

    p*      Match p zero or more times.
            If p is a character match, don't allow whitespace in between each
            character and store a string, otherwise store list(p).
    p+      As above but p must match at least once.
    p?      Match p zero or once. Stores optional(p).
    p*? q   Same as p* but limit until q matches. Stores tuple(type of p*, q)
    p+? q   Same as p+ but limit until q matches. Stores tuple(type of p+, q)
            These five operations are non-constant.

    p -> r  Match p through calling the alternate begin rule r.

    n : p   Match p and store it in an attribute named n.
            Acts as though it stores nothing to the rule calling it.

    p - q   Shortcut for (&!p q)

    p % q   Match p joined by whitespace and q.  Stores list(p). non-constant.

    p as q  Match p but store to it using the parser type q. The type of p 
            must be compatible with the type of q.

    p > q   Same as (p q) but if p matches and q does not, raise a global 
            error.

    p >^ q  Same as (p ^ q) but if p matches and q does not, raise a global 
            error.

    p >> q  Same as p > q, but in addition to q, enforce that the current
            object being parsed must succeed or raise a global failure.

    p >>^ q Same as p >^ q, but in addition to q, enforce that the current
            object being parsed must succeed or raise a global failure.

    p ^ q   Match p followed by q with no whitespace between.
            Stores type_join(p q).

    p q     Match p followed by q.
            If p and q are both character matches then it is equivalent to 
            (p ^ q).
            If q would also match the Whitespace rule then it is equivalent to
            (p ^ skip (Whitespace - q) ^ q).
            Otherwise allow optional whitespace to separate them and
            store tuple(p, q).

    p { d } If p is matched perform action d.

    function  See Functions

    p | q   Try to match p, then try to match q if that fails.
            Stores variant(store p, store q). Non-constant.

    p || q  Matches the same as (p | p q)  but stores 
            tuple(optional(p), optional(q)).

    p ~ q   Match p followed by q separated by optional whitespace.
            Non-constant. Stores tuple(p, q).

Type storage
    nothing         Is a const type.
    tuple(...)      Removes const types from the tuple.
    tuple(q) -> q   Single element tuple is not a tuple.
        s = "p" [a-z]
        type(s) = tuple(nothing, character)
                => tuple(character)
                => character

    variant(..., variant(...), ...) -> variant(..., ..., ...)
        s = 'a' | (Integer | Float)
        type(s) = variant(character, variant(int, float))
        type(s) = variant(character, int, float)

    variant()       Types which are the same are removed from the variant.
    variant(q) -> q
        s = 'a' | 'b'
        type(s) = variant(character, character)
        type(s) = variant(character)
        type(s) = character

    variant(..., character, ..., string, ...) -> variant(string)
        s = 'blimey' | Integer | 'a' | 'b'
        type(s) = variant(string, int, character, character)
        type(s) = variant(string, int, character)
        type(s) = variant(string, int)

Actions
    fail(message:string)    Raise global failure with indicated message.
